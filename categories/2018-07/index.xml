<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>2018-07 on 付辉</title>
    <link>/categories/2018-07/</link>
    <description>Recent content in 2018-07 on 付辉</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 19 Jul 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/categories/2018-07/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>siege压测</title>
      <link>/blog/2018/07-19-siege%E5%8E%8B%E6%B5%8B/</link>
      <pubDate>Thu, 19 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/2018/07-19-siege%E5%8E%8B%E6%B5%8B/</guid>
      <description>关于压测，首先要了解TPS和并发用户数之间的关系：
 TPS就是每秒事务数，但是事务是基于虚拟用户数的。假如1个虚拟用户在1秒内完成1笔事务，那么TPS明显就是1；如果某笔业务响应时间是1ms，那么1个用户在1秒内能完成1000笔事务，TPS就是1000了；如果某笔业务响应时间是1s,那么1个用户在1秒内只能完 成1笔事务，要想达到1000TPS，至少需要1000个用户；因此可以说1个用户可以产生1000TPS，1000个用户也可以产生1000TPS，无非是看响应时间快慢。
 针对上面的描述，引申出了命令的三个属性：
-c : This option allows you to set the concurrent number of users -r : This option tells each siege user how times it should run. -t : This option specify the number of times each user should run  对于linux的命令，其实man查看就足够了。</description>
    </item>
    
    <item>
      <title>Linux查看监听的端口进程</title>
      <link>/blog/2018/07-10-linux%E6%9F%A5%E7%9C%8B%E7%9B%91%E5%90%AC%E7%9A%84%E7%AB%AF%E5%8F%A3%E8%BF%9B%E7%A8%8B/</link>
      <pubDate>Tue, 10 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/2018/07-10-linux%E6%9F%A5%E7%9C%8B%E7%9B%91%E5%90%AC%E7%9A%84%E7%AB%AF%E5%8F%A3%E8%BF%9B%E7%A8%8B/</guid>
      <description>Netstat 是一款命令行工具，可用于列出系统上所有的网络套接字连接情况，包括 tcp, udp 以及 unix 套接字。另外它还能列出处于监听状态（即等待接入请求）的套接字。经常使用 netstat 用于查看网络连接信息和系统开启的端口号。
 还有一个完美替代它的命令ss，全称是socket statistics。ss的优点就在于“天下武功唯快不破”。
引言 已知服务监听的端口，想查找当前服务的PID。我们可以拆解成2个子问题： 1. 如何查看该端口是否在被服务监听 2. 如何查看该端口的PID
ps 用于查看服务器上的进程信息.最最常用的就是:
ps -ef  netstat 显示的状态列：Proto，Recv-Q，Send-Q，Local Address，Foreign Address，State。其中Recv-Q和Send-Q分别代表接收队列和发送队列。这些数字一般都是0，如果不是，则表示软件包正在队列中堆积。
Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 enlightened:domain *:* LISTEN  比较有用的选项是：
 -n：Show network addresses as numbers (normally netstat interprets addresses and attempts to display them symbolically). This option may be used with any of the display formats.</description>
    </item>
    
    <item>
      <title>mitmproxy使用</title>
      <link>/blog/2018/07-06-mitmproxy%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Fri, 06 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/2018/07-06-mitmproxy%E4%BD%BF%E7%94%A8/</guid>
      <description>介绍一款非常好用的抓包工具，官网地址：https://www.mitmproxy.org。实际上，在调试苹果IAP支付时，始终没有抓成功过，反而因为设置了代理，导致苹果沙盒用户无法成功支付。它名字的全拼是Man-in-the-middle-proxy，代表中间人攻击。
常用的快捷键  在列表界面，按回车进入详情界面 在详情界面，按q返回列表界面 在详情界面，按tab键在Request,Response,Detail三个tab之间切换。按j，k可以滚动查看详情. 在列表界面，按G跳到最新一个请求 在列表界面，按g跳到第一个请求 在列表界面，按d删除当前选中的请求，按D恢复刚才删除的请求 在列表界面，按z清空请求列表  常用的过滤表达式 列表界面,按f进入过滤模式。详细的过滤表达式，可以查看：Filter expressions。 1. ~h regex Header . ~u regex URL 3. ~m regex Method
原理  Subject Alternative Name：is an extension to X.509 that allows various values to be associated with a security certificate using a subjectAltName field. These values are called Subject Alternative Names (SANs). Names include Server Name Indication： is an extension to the TLS computer networking protocol by which a client indicates which hostname it is attempting to connect to at the start of the handshaking process.</description>
    </item>
    
    <item>
      <title>MySQL事务</title>
      <link>/blog/2018/07-01-mysql%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Sun, 01 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/2018/07-01-mysql%E4%BA%8B%E5%8A%A1/</guid>
      <description>关于MySQL事务的诡异问题，至今没有调查出原因。但却也是一个契机，带我重新回忆之前的遇到的事务问题。
诡异的问题 系统中存在A和B两个表。B表中有两个关键字段：一个是唯一索引transaction_id，还有一个是标识处理状态的status。当status=0表示记录未被处理，status=1表示记录处理过了，不需要再处理了。
如果B中记录未处理，则在A表中插入一条权益记录，同时更新status=1，后续就不能再给用户加权益了。
代码做了如下处理：
func sessPart() { //开启事务 session := engine.NewSession() sess.Begin() defer session.Close() defer sess.Rollback() //插入价钱100分的权益交付记录 exchange := models.Exchange{Money: 100, Uid: 1} _, err := sess.Insert(exchange) if err != nil { sess.Rollback() return } //更新status为1 //并且使用乐观锁，防止因没有匹配到数据，直接返回成功 testModel := Test{ Status: 1, } affectRows, err := sess.Where(&amp;quot;transaction_id = ? AND status = 0&amp;quot;, 1). Cols(&amp;quot;status&amp;quot;).Update(&amp;amp;testModel) if err != nil || affectRows == 0 { sess.Rollback() return } sess.Commit() } //测试事务的并发情况 func BenchmarkLock(b *testing.</description>
    </item>
    
  </channel>
</rss>