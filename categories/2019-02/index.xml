<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>2019-02 on 道法自然</title>
    <link>/categories/2019-02/</link>
    <description>Recent content in 2019-02 on 道法自然</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 15 Feb 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/categories/2019-02/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Mark-sweep GC</title>
      <link>/blog/2019/2019-02-15-mark-sweep-gc/</link>
      <pubDate>Fri, 15 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/2019/2019-02-15-mark-sweep-gc/</guid>
      <description>把事做成的才是赢家，在口头上压倒对手，真的没有那么重要！
—— 大道至简
 Whirlwind introduce 当对象不再被引用时，对象不会立即被垃圾回收。也不存在任何子系统来专门记录使用的内存情况。
当系统没有内存空间时，触发GC处理。它首先会枚举所有的Root对象，然后递归的遍历根对象的引用关系。给遍历到的对象设置一个特殊标记，表明该对象是可达的，空间不能被回收。
当标记结束后，GC进入清洗阶段，任何在内存中没有被这次垃圾回收标记的对象都会被系统回收。
The algorithm 程序主要包含3个阶段：列举所有Root对象、标记起始于Root的对象引用、清除无效的对象。
void GC() { HaltAllProcessing(); ObjectCollection roots = GetRoots(); for(int i = 0; i &amp;lt; roots.Count(); ++i) Mark(roots[i]); Sweep(); }  Root Enumeration Root Enumeration会列举系统所有对象引用。运行系统需要为GC提供一种获取Root对象列表的机制。比如，在.NET中JIT维护了当前活跃的root对象，提供了获取根对象列表的API。
一个函数接受一个指针类型的参数，当方法返回时，jitter会识别出该参数不会再被使用，而将其从root中移除。
Mark 每个对象在创建时创建额外的空间，用于去mark这个对象，这个过程也是递归的
void Mark(Object* pObj) { if (!Marked(pObj)) // Marked returns the marked flag from object header { MarkBit(pObj); // Marks the flag in obj header // Get list of references that the current object has // and recursively mark them as well ObjectCollection children = pObj-&amp;gt;GetChildren(); for(int i = 0; i &amp;lt; children.</description>
    </item>
    
    <item>
      <title>新年彩蛋之中大奖</title>
      <link>/blog/2019/2019-02-08-%E6%96%B0%E5%B9%B4%E5%BD%A9%E8%9B%8B%E4%B9%8B%E4%B8%AD%E5%A4%A7%E5%A5%96/</link>
      <pubDate>Sat, 09 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/2019/2019-02-08-%E6%96%B0%E5%B9%B4%E5%BD%A9%E8%9B%8B%E4%B9%8B%E4%B8%AD%E5%A4%A7%E5%A5%96/</guid>
      <description>2019年计划通过福利彩票发家致富的，可以好好看一看这篇博客。作为新年彩蛋来送给大家，也希望大家能真的中大奖。
—— 新年快乐，给每个有梦想的程序员
 生成随机号 小概率事件也要做的一丝不苟，大家都是程序员，为啥要用别人家写的随机代码。嘎嘎！
双色球蓝号1-12、红号1-33，非常简单，只需保证生成的红号不相互重复就可以，然后就是考虑如何做到真正的随机。
还有一个问题就是如何存储一组号码。首先，分成红区和蓝区两部分，最后一个号约定为蓝号。另外，为了方便存储，我们放弃了将每个数字用符号连接的方式，而是自定义了34进制，用于保证每组号码的长度都是7。
var redBall = map[int]rune{ 1: &#39;1&#39;, 2: &#39;2&#39;, 3: &#39;3&#39;, //...... 31: &#39;V&#39;, 32: &#39;W&#39;, 33: &#39;X&#39;, } var redFlip = map[rune]int{ &#39;1&#39;: 1, &#39;2&#39;: 2, &#39;3&#39;: 3, //... &#39;V&#39;: 31, &#39;W&#39;: 32, &#39;X&#39;: 33, }  我们提供一个编解码的方法，用于将字符串转换为一组号码。对应的，将一组号码转换为长度为7的字符串。
随机红号范围控制在1-33，蓝号控制在1-16。所以，我们对当前纳秒进行取余，便可以保证数据的正确。对于去重部分，通过map属性来达到目的，map的key存储生成的随机号，value存储对应的编码。因为map结构读取数据时本身也是随机的，所以在生成红号和蓝号的时候便多生成一部分，最后再取6个红号，1个蓝号。
type TwoColor struct { } //encode func (color *TwoColor) Encode(origin []int) string { runes := make([]rune, 0) for _, v := range origin { if elem, ok := redBall[v]; ok { runes = append(runes, elem) } return string(runes) } //decode func (color *TwoColor) Decode(origin string) []int { result := make([]int, 0) for _, v := range origin { if elem, ok := redFlip[v]; ok { result = append(result, elem) } } return result } //generate random numbers func (color *TwoColor) GenerateRandom() string { redResult := make(map[int]rune, 12) for len(redResult) &amp;lt; 12 { key := time.</description>
    </item>
    
    <item>
      <title>垃圾回收之引用计数</title>
      <link>/blog/2019/19-02-01-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B9%8B%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/</link>
      <pubDate>Fri, 01 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/2019/19-02-01-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B9%8B%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/</guid>
      <description>思来想去，决定总结一下垃圾回收机制。引用计数与我结缘最早，也比较简单、基础，遂决定从引用计数入手。
—— 不管人非笑，不管人毁谤，不管人荣辱，任他功夫有进有退，我只是这致良知的主宰不息，久久自然有得力处
 Reference Counting 对象在创建时保存一个自身被引用的计数，初始值为1。每次被新的变量引用，该值加1。相反，则减去1。当该值等于0时，占用空间被系统回收。
什么是对象呢？ var neojos int64 = 32 var ptrNeojos *int64 = &amp;amp;name  如上所示，我们创建了一个int64类型的object，命名为neojos。程序中对该object的操作都是通过使用neojos来实现的。而ptrNeojos其实又创建了一个*int64类型的object，但它的值保存的是neojos的地址。
对于ptrNeojos来说，它的生命周期跟普通变量的生命周期没有区别。唯一区别的是，当它生命周期结束后，ptrNeojos会被垃圾回收，而底层指向的object却不会。
如何计数呢？ Object * obj1 = new Object(); // RefCount(obj1) starts at 1 Object * obj2 = obj1; // RefCount(obj1) incremented to 2 as new reference is added Object * obj3 = new Object(); obj2-&amp;gt;SomeMethod(); obj2 = NULL; // RefCount(obj1) decremented to 1 as ref goes away obj1 = obj3; // RefCount(obj1) decremented to 0 and can be collected  obj1指向了一个匿名对象，为了方便，我们叫anonymousObj。上述代码展示了anonymousObj从创建到被垃圾回收的整个过程。垃圾回收对象的内存空间，上述过程中obj1对象的地址不会发生改变，只是底层引用的对象发生了变化。</description>
    </item>
    
  </channel>
</rss>