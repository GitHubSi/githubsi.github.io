<!DOCTYPE html>
<html>

<head>
    
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer">

<meta name="description" content="Hugo-Primer theme&#39;s example site">
<title>
    MySQL事务（2） - 渐行渐远
</title>









<link rel="stylesheet" href="/css/main.min.ea2156633063385371d7a4d9db559868e643a3885ab887da32f7ea8a1e05ee11.css" integrity="sha256-6iFWYzBjOFNx16TZ21WYaOZDo4hauIfaMvfqih4F7hE=" crossorigin="anonymous" media="screen">





<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic">
<script
        src="https://code.jquery.com/jquery-3.5.1.min.js"
        integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0="
        crossorigin="anonymous"></script>

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="MySQL事务（2）"/>
<meta name="twitter:description" content="花繁柳密能拨开方见手段，风狂雨骤时可立定才是脚跟。 引言 在MySQL处理事务的过程中，遇到如下报错： Error 1205: Lock wait timeout exceeded; try restarting transaction 结合日志信息，很快的定位"/>

<meta property="og:title" content="MySQL事务（2）" />
<meta property="og:description" content="花繁柳密能拨开方见手段，风狂雨骤时可立定才是脚跟。 引言 在MySQL处理事务的过程中，遇到如下报错： Error 1205: Lock wait timeout exceeded; try restarting transaction 结合日志信息，很快的定位" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://neojos.com/blog/2019/19-02-28-mysql%E4%BA%8B%E5%8A%A12/" />
<meta property="article:published_time" content="2019-02-28T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2019-02-28T00:00:00&#43;00:00"/>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-12345678-0', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

    

    
    
    
    <title>
        
        MySQL事务（2）
        
    </title>
</head>

<body>

    
    
    <header class="text-center container">
        <h1 class="mb-4 mt-2">MySQL事务（2）</h1>
    </header>
    
    <main class="wrap">
        
<div class="container">
    <aside role="complementary">
        <div class="tag-container">
            
            
            <span class="tag">
                <a href="/tags/transaction/" class="badge badge-success">
                    transaction
                </a>
            </span>
            
            
        </div>
        <div class="float-right badge badge-light">02-28-2019 &#183; 922 words</div>
    </aside>
    <hr />
    <article role="article">
        

<blockquote>
<p><code>花繁柳密能拨开方见手段，风狂雨骤时可立定才是脚跟。</code></p>
</blockquote>

<h2 id="引言">引言</h2>

<p>在<code>MySQL</code>处理事务的过程中，遇到如下报错：</p>

<pre><code>Error 1205: Lock wait timeout exceeded; try restarting transaction
</code></pre>

<p>结合日志信息，很快的定位了问题代码并做了修复，但这个报错却一直存在。观念里，只要等待一段时间，这个错误就应该消失啊，是哪里出问题了？</p>

<h2 id="问题">问题</h2>

<p>代码在执行<code>Begin</code>之后，处理到某个逻辑直接<code>return</code>处理，没有关闭事务导致的。因为<code>SQL</code>操作的记录一直占着锁得不到释放，所以后续对该行记录进行写操作时，就会报这个错误。示例代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">notify</span> <span class="o">*</span><span class="nx">Sign</span><span class="p">)</span> <span class="nf">HandleSign</span><span class="p">(</span><span class="nx">ctx</span> <span class="o">*</span><span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>

	<span class="c1">// 事务操作，开启事务
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ses</span><span class="p">.</span><span class="nf">Begin</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="c1">// 这里需要特别注意，正常情况必须加上
</span><span class="c1"></span>	<span class="c1">// defer ses.Close()
</span><span class="c1"></span>
	<span class="c1">// 更新Log表记录
</span><span class="c1"></span>	<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ses</span><span class="p">.</span><span class="nf">Where</span><span class="p">(</span><span class="s">&#34;id = ?&#34;</span><span class="p">,</span> <span class="nx">contractLog</span><span class="p">.</span><span class="nx">Id</span><span class="p">).</span><span class="nf">Cols</span><span class="p">(</span><span class="s">&#34;status&#34;</span><span class="p">).</span><span class="nf">Update</span><span class="p">(</span><span class="nx">contractLog</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">ses</span><span class="p">.</span><span class="nf">Rollback</span><span class="p">()</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="c1">//这个地方直接return导致的，这个事务没有关闭，导致上面的锁一直没有释放
</span><span class="c1"></span>	<span class="k">return</span> <span class="kc">nil</span>

	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ses</span><span class="p">.</span><span class="nf">Commit</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="nx">ses</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
<span class="p">}</span></code></pre></div>
<p>问题的关键就在于<code>Begin</code>后，没有执行<code>Rollback</code>或<code>Commit</code>，导致事务没有被关闭。这里特别强调<code>defer close()</code>的作用，下面是文档对<code>Close</code>的注释。</p>

<blockquote>
<p><code>Close release the connection from pool</code></p>

<p><code>When Close be called, if session is a transaction and do not call Commit or Rollback, then call Rollback</code></p>
</blockquote>

<h2 id="processlist"><code>PROCESSLIST</code></h2>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SHOW</span> <span class="p">[</span><span class="k">FULL</span><span class="p">]</span> <span class="n">PROCESSLIST</span></code></pre></div>
<p>使用如上命令，查看是否存在一个线程执行占用了很长的时间，这体现在它<code>Sleep</code>的时间上。果不其然，确实有那么一个，但我忍住没有<code>KILL</code>它。因为我无法确定就是这个线程导致的。</p>

<blockquote>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/show-processlist.html"><code>SHOW PROCESSLIST</code></a> shows which threads are running. If you have the <a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_process"><code>PROCESS</code></a> privilege, you can see all threads. Otherwise, you can see only your own threads (that is, threads associated with the MySQL account that you are using). If you do not use the <code>FULL</code> keyword, only the first 100 characters of each statement are shown in the <code>Info</code> field.</p>
</blockquote>

<h2 id="show-engine-innodb-status"><code>SHOW ENGINE INNODB STATUS</code></h2>

<blockquote>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/show-engine.html"><code>SHOW ENGINE INNODB STATUS</code></a> displays extensive information from the standard <code>InnoDB</code> Monitor about the state of the <code>InnoDB</code> storage engine. For information about the standard monitor and other <code>InnoDB</code> Monitors that provide information about <code>InnoDB</code> processing, see <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-monitors.html">Section 15.16, “InnoDB Monitors”</a>.</p>
</blockquote>

<p>一上来就引用<a href="https://dev.mysql.com/doc/refman/8.0/en/show-engine.html"><code>SHOW ENGINE Syntax</code></a>也是因为没有接触过这个命令，网上说：当你更新表中的某条记录时，如果一些别的线程对这条记录上了锁，并且执行占用时间较长的话，就会导致你对该条记录的操作超时。</p>

<p>不过非常遗憾，我查看了它输出的结果，并没有显示出这条问题<code>SQL</code>。</p>

<h2 id="innodb-lock-wait-timeout-https-dev-mysql-com-doc-refman-5-7-en-innodb-parameters-html-sysvar-innodb-lock-wait-timeout"><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_lock_wait_timeout"><code>innodb_lock_wait_timeout</code></a></h2>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="s1">&#39;innodb_lock_wait_timeout&#39;</span><span class="p">;</span></code></pre></div>
<p>当事务没有被释放时，后续事务执行失败的等待时间就是由这个设置决定的。当事务访问这条记录超过这个时间还无法获得锁，就会报引言中的错误。</p>

<blockquote>
<p>The length of time in seconds an <code>InnoDB</code> <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_transaction">transaction</a> waits for a <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_row_lock">row lock</a> before giving up. The default value is 50 seconds. A transaction that tries to access a row that is locked by another <code>InnoDB</code> transaction waits at most this many seconds for write access to the row before issuing the following error</p>
</blockquote>

<p>参考文章：</p>

<ol>
<li><a href="https://stackoverflow.com/questions/5836623/getting-lock-wait-timeout-exceeded-try-restarting-transaction-even-though-im"><code>stackoverflow problem</code></a></li>
</ol>

    </article>
</div>


        
<nav role="navigation" class="bottom-menu">
    

    
        <a href="/blog">back</a>
        
    

    
</p>
</nav>

    </main>
    
    <footer class="container footer"></footer>
    
    
</body>

</html>