<!DOCTYPE html>
<html>
  <head>
    
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-12345678-0', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
  database.sql.driver &ndash; 渐行渐远

    </title>
    
    
    <meta name="description" property="og:description" content="在事务操作中，要求事务的各个阶段都使用一个Conn连接。在连接被关闭之前，还需要执行rollback操作。 文章翻译了Go源码下databas|Hugo-Primer theme&#39;s example site">
    

    <meta name="apple-mobile-web-app-title" content="渐行渐远">
    
    
    
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@">
    <meta name="twitter:creator" content="@">
    <meta name="twitter:title" content="database.sql.driver | 渐行渐远">
    <meta name="twitter:description" content="在事务操作中，要求事务的各个阶段都使用一个Conn连接。在连接被关闭之前，还需要执行rollback操作。 文章翻译了Go源码下databas|Hugo-Primer theme&#39;s example site">
    <meta name="twitter:image" content="https://neojos.com/twitter-card.png">
    


    <link rel="stylesheet" href="/assets/syntax.css">
    <link rel="stylesheet" href="/assets/primer-build.css">
    <link rel="stylesheet" href="/assets/style.css">
  </head>


  <body class="bg-gray">
    <div id="holy" class="container-lg bg-white h-100">

      <div id="header" class="px-1 bg-white">
        <nav class="UnderlineNav UnderlineNav--right px-2">
  <a class="UnderlineNav-actions muted-link h2" href="https://neojos.com/">
    渐行渐远
  </a>

  
  
</nav>

      </div>

      <div role="main" id="main" class="holy-main markdown-body px-4 bg-white">
        

<div class="Subhead">
  <div class="Subhead-heading">
    <div class="h1 mt-3 mb-1">database.sql.driver</div>
  </div>
  <div class="Subhead-description">
    




<a href='/tags/mysql' class="muted-link">
  <span class="Label Label--gray">MySQL</span>
</a>

<a href='/tags/golang' class="muted-link">
  <span class="Label Label--gray">golang</span>
</a>



    
    <div class="float-md-right">
      <span title="Lastmod: 2019-07-17. Published at: 2019-07-17.">
        
          Published: 2019-07-17
        
      </span>
    </div>
    
  </div>
</div>
<article>
  
  <section class="pb-6 mb-3 border-bottom">
    <p>在事务操作中，要求事务的各个阶段都使用一个<code>Conn</code>连接。在连接被关闭之前，还需要执行<code>rollback</code>操作。</p>

<p>文章翻译了<code>Go</code>源码下<code>database.sql.driver</code>的接口规范，具体实现可以查看源码。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 包driver定义了数据驱动要实现的接口，具体的实现会在包sql中用到。
</span><span class="c1">//
</span><span class="c1">// 更多还是使用包sql中的代码
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">driver</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;context&#34;</span>
	<span class="s">&#34;errors&#34;</span>
	<span class="s">&#34;reflect&#34;</span>
<span class="p">)</span>

<span class="c1">// Value必须是一个驱动可以处理的值、NamedValueChecker接口能够处理的类型
</span><span class="c1">// 或者下面这些类型的实例
</span><span class="c1">//
</span><span class="c1">//   int64
</span><span class="c1">//   float64
</span><span class="c1">//   bool
</span><span class="c1">//   []byte
</span><span class="c1">//   string
</span><span class="c1">//   time.Time
</span><span class="c1">//
</span><span class="c1">// 如果驱动支持游标，返回值可能也实现Rows接口。举例，当用户
</span><span class="c1">// 执行&#34;select cursor(select * from my_table) from dual&#34;。
</span><span class="c1">// 如果返回的Rows被Close掉了，游标指向的数据也会被Close掉。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Value</span> <span class="kd">interface</span><span class="p">{}</span>

<span class="c1">// NameValue 同时包括name和value
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">NamedValue</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// 如果Name不为空，它应该被用于参数标识符，而非序号位置。
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Name 没有符号前缀
</span><span class="c1"></span>	<span class="nx">Name</span> <span class="kt">string</span>

	<span class="c1">// 参数从1开始的序号位置，并且总是被设置
</span><span class="c1"></span>	<span class="nx">Ordinal</span> <span class="kt">int</span>

	<span class="c1">// Value是参数值
</span><span class="c1"></span>	<span class="nx">Value</span> <span class="nx">Value</span>
<span class="p">}</span>

<span class="c1">// Driver是一个必须被各个数据库driver实现的接口
</span><span class="c1">//
</span><span class="c1">// 数据库驱动可以实现DriverContext来访问上下文，并且只解析一次连接池的名称，
</span><span class="c1">// 而非每个连接都解析一次。
</span><span class="c1">// 
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Driver</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// Open返回数据库的一个新连接，参数name是驱动特定格式的字符串
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Open也可以返回一个缓存的连接（之前被close掉的），但这样
</span><span class="c1"></span>	<span class="c1">// 做其实没必要。sql包为了连接重复使用维护了一个空闲连接池
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// 返回的连接一次只被一个goroutinue中使用
</span><span class="c1"></span>	<span class="nf">Open</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">Conn</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 如果Driver实现了DriverContext接口，那么sql.DB就会调用OpenConnector
</span><span class="c1">// 来获取一个Connector，调用Connector的Conn方法来获取每个需要的连接，
</span><span class="c1">// 以此代替调用Drive的Open方法。这样允许drivers仅解析一次name，同时提供
</span><span class="c1">// 对每个连接上下文的访问
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">DriverContext</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// OpenConnector解析name的方式必须跟Driver.Open的方式保持一致
</span><span class="c1"></span>	<span class="nf">OpenConnector</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">Connector</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 一个Connector表示一个固定配置的driver，能够创建任意数量的等效Conn，
</span><span class="c1">// 供多个goroutinue使用
</span><span class="c1">//
</span><span class="c1">// 一个Connector能被传递给sql.OpenDB方法，去允许驱动实现自己的sql.DB。
</span><span class="c1">// 或者通过调用DriverContext的OpenConnector方法，来返回一个Connector，
</span><span class="c1">// 这样允许驱动访问连接的上下文，避免频繁的解析驱动配置。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Connector</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// Connect返回一个数据库的连接
</span><span class="c1"></span>    <span class="c1">// Connect可能返回一个之前缓存的连接（之前被close掉了），但这样去
</span><span class="c1"></span>    <span class="c1">// 做其实是没必要的。sql包维护了一个高效重复使用的空闲连接池。
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// 被提供的context.Context参数仅仅被用于创建连接的目的
</span><span class="c1"></span>	<span class="c1">//（看net.DialContext),不应该被存储或用于其他别的目的。
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// 返回的连接一次只能被一个goroutine使用
</span><span class="c1"></span>	<span class="nf">Connect</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">Conn</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

	<span class="c1">// Driver返回Connector的底层驱动，在sql.DB中，主要用于维护
</span><span class="c1"></span>	<span class="c1">// 驱动的扩展性
</span><span class="c1"></span>	<span class="nf">Driver</span><span class="p">()</span> <span class="nx">Driver</span>
<span class="p">}</span>

<span class="c1">// ErrSkip 可能被一些可选接口的方法返回，用于在运行时标识该路径无效。
</span><span class="c1">// 包sql应该继续去执行，就当类型没有实现这个接口一样。
</span><span class="c1">// ErrSkip 只有在被明确说明后才会被支持
</span><span class="c1">// 
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">ErrSkip</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;driver: skip fast-path; continue as if unimplemented&#34;</span><span class="p">)</span>

<span class="c1">// 当驱动给sql包标识一个driver.Conn处于坏的状态时，ErrBadConn应该被返回（
</span><span class="c1">// 比如服务端已经关闭了这个连接），sql包已经使用一个新的连接进行重试
</span><span class="c1">//
</span><span class="c1">// 为了避免重复操作，如果服务端可能已经完成操作的话，ErrBadConn不应该被返回。
</span><span class="c1">// 即使服务端返回了一个错误，你也不应该返回ErrBadConn
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">ErrBadConn</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;driver: bad connection&#34;</span><span class="p">)</span>

<span class="c1">// Pinger是一个可选的接口，它可能会被Conn实现
</span><span class="c1">// 
</span><span class="c1">// 如果Conn没有实现Pinger接口，那么sql包的DB.Ping和DB.PingContext
</span><span class="c1">// 将会执行检查，是否至少存在一个可用连接
</span><span class="c1">//
</span><span class="c1">// 如果Conn.Ping返回了ErrBadConn，DB.Ping 和 DB.PingContext将会从连接池中
</span><span class="c1">// 将Conn溢出
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Pinger</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Ping</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>

<span class="c1">// Execer 是一个可以被Conn实现的，可选的接口
</span><span class="c1">//
</span><span class="c1">// 如果Conn实现了ExecerContext或Excer，
</span><span class="c1">// 包sql下的DB.Exec将首先prepare查询语句，执行然后关闭。
</span><span class="c1">//
</span><span class="c1">// Exec可能返回ErrSkip错误
</span><span class="c1">//
</span><span class="c1">// 弃用：Drivers应该实现ExecerContext接口来替代Execer
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Execer</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Exec</span><span class="p">(</span><span class="nx">query</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="p">[]</span><span class="nx">Value</span><span class="p">)</span> <span class="p">(</span><span class="nx">Result</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// ExecerContext是可以被Conn实现的、可选的接口
</span><span class="c1">//
</span><span class="c1">// 如果Conn并没有实现ExecerContext接口，那sql包的DB.Exec将会向后调用Excer
</span><span class="c1">// 如果Conn也没有实现Execer接口，
</span><span class="c1">// DB.Exec将首先prepare查询，执行语句、然后关闭语句
</span><span class="c1">//
</span><span class="c1">// ExecerContext 可能返回 ErrSkip错误.
</span><span class="c1">//
</span><span class="c1">// ExecerContext必须认真对待context的超时，当context被取消时，需要返回。
</span><span class="c1">// 
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ExecerContext</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">ExecContext</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">query</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="p">[]</span><span class="nx">NamedValue</span><span class="p">)</span> <span class="p">(</span><span class="nx">Result</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Queryer 是一个可选的接口，Conn可能会实现它。
</span><span class="c1">//
</span><span class="c1">// 如果Conn既没有实现QueryerContext，也没有实现Queryer
</span><span class="c1">// 那么sql包的DB.Query首先会prepare一个查询语句，然后执行语句，关闭语句
</span><span class="c1">//
</span><span class="c1">// Query可能会返回 ErrSkip错误.
</span><span class="c1">//
</span><span class="c1">// 弃用：Drivers应该实现QueryerContext接口来替代Queryer
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Queryer</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Query</span><span class="p">(</span><span class="nx">query</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="p">[]</span><span class="nx">Value</span><span class="p">)</span> <span class="p">(</span><span class="nx">Rows</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// QueryerContext 是一个可选的接口，Conn可能会实现它
</span><span class="c1">//
</span><span class="c1">// 如果Conn没有实现QueryerContext，那么sql包在执行DB.Query会降级调用Queryer；
</span><span class="c1">// 如果Conn也没有实现Queryer，DB.Query 首先会prepare一个查询语句，然后执行这个语句
</span><span class="c1">// 然后再关闭它
</span><span class="c1">//
</span><span class="c1">// QueryerContext可能会返回 ErrSkip.
</span><span class="c1">//
</span><span class="c1">// QueryerContext必须认真对待context的超时，当context被cancel掉时，需要返回
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">QueryerContext</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">QueryContext</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">query</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="p">[]</span><span class="nx">NamedValue</span><span class="p">)</span> <span class="p">(</span><span class="nx">Rows</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Conn是一条数据库的连接，它不能在多个goroutine中同时使用。
</span><span class="c1">//
</span><span class="c1">// Conn被假定为是有状态的
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Conn</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// Prepare返回一个准备好的语句，绑定到这个连接上
</span><span class="c1"></span>	<span class="nf">Prepare</span><span class="p">(</span><span class="nx">query</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">Stmt</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

	<span class="c1">// Close会使当前准备好的语句和事物失效，并可能停止它们执行，
</span><span class="c1"></span>	<span class="c1">// 将这个连接标记为不再使用
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// 因为sql包维护了一个空闲连接池，仅当前有多余的空闲连接时，
</span><span class="c1"></span>	<span class="c1">// 才会调用Close。对于驱动来说，实现自己的连接缓存是不必要的
</span><span class="c1"></span>	<span class="nf">Close</span><span class="p">()</span> <span class="kt">error</span>

    <span class="c1">// Begin 启动并返回一个新的事务
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// 弃用：驱动应该通过实现ConnBeginTx来替换Begin
</span><span class="c1"></span>	<span class="nf">Begin</span><span class="p">()</span> <span class="p">(</span><span class="nx">Tx</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// ConnPrepareContext通过使用context，加强了Conn接口
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ConnPrepareContext</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// context被用来对语句做预处理
</span><span class="c1"></span>	<span class="c1">// 在语句本身中是不可以存储context的
</span><span class="c1"></span>	<span class="nf">PrepareContext</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">query</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">Stmt</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// IsolationLevel在TxOptions类型中记录事物的隔离级别
</span><span class="c1">//
</span><span class="c1">// 这个类型应该认被为跟sql.IsolationLevel是一致的，以及定义这个类型的其他值。
</span><span class="c1">// 
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">IsolationLevel</span> <span class="kt">int</span>

<span class="c1">// TxOptions 设置事物的选项
</span><span class="c1">//
</span><span class="c1">// 这个类型应该被认为跟sql.TxOptions是一致的
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">TxOptions</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Isolation</span> <span class="nx">IsolationLevel</span>
	<span class="nx">ReadOnly</span>  <span class="kt">bool</span>
<span class="p">}</span>

<span class="c1">// ConnBeginTx通过context和TxOptions提高了Conn接口
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ConnBeginTx</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// BeginTx启动并返回一个新的事务
</span><span class="c1"></span>    <span class="c1">// 如果context被用户取消了，sql包会在丢弃和关闭这个连接之前
</span><span class="c1"></span>    <span class="c1">// 执行Tx.Rollback
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// 函数必须检查opts.Isolation，确定是否存在设置的额隔离级别。
</span><span class="c1"></span>	<span class="c1">// 如果驱动不支持一个非默认的隔离级别和被设置的级别，或者
</span><span class="c1"></span>	<span class="c1">// 存在一个非默认的隔离级别是不支持的，必须返回一个错误
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// 函数也必须检查opts.ReadOnly，如果ReadOnly值为真，
</span><span class="c1"></span>	<span class="c1">// 如果支持设置的话，则设置只读事务属性。如果不支持的话，返回error
</span><span class="c1"></span>	<span class="c1">// 
</span><span class="c1"></span>	<span class="nf">BeginTx</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">opts</span> <span class="nx">TxOptions</span><span class="p">)</span> <span class="p">(</span><span class="nx">Tx</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Conn可能会实现SessionResetter接口，用于重置当前连接上的会话状态
</span><span class="c1">// 并将当前连接标识为坏连接
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SessionResetter</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// 当连接在连接池中时，调用ResetSession方法。该连接不会再承载任何查询操作
</span><span class="c1"></span>	<span class="c1">// 直接方法返回
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// 如果连接是坏的，方法应该返回driver.ErrBadConn错误，来阻止连接被放回到
</span><span class="c1"></span>	<span class="c1">// 连接池。其他别的错误将会被丢弃
</span><span class="c1"></span>	<span class="nf">ResetSession</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>

<span class="c1">// Result是查询执行的结果
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Result</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// LastInsertId返回数据库自动生成的ID，比如，用主键插入表的操作
</span><span class="c1"></span>	<span class="nf">LastInsertId</span><span class="p">()</span> <span class="p">(</span><span class="kt">int64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

	<span class="c1">// RowsAffected返回查询影响的行数
</span><span class="c1"></span>	<span class="nf">RowsAffected</span><span class="p">()</span> <span class="p">(</span><span class="kt">int64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Stmt是一个准备好的语句，它被绑定到一个Conn，且不能被多个goroutine并发
</span><span class="c1">// 使用
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Stmt</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// Close关闭这个语句
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// 截止到Go 1.1，如果Stmt在被一些查询使用，Stmt将不会被关闭
</span><span class="c1"></span>	<span class="nf">Close</span><span class="p">()</span> <span class="kt">error</span>

	<span class="c1">// NumInput返回占位符的个数
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// 如果NumInput返回值大于等于0，sql包会明智的检查调用者的参数个数，
</span><span class="c1"></span>	<span class="c1">// 在Exec或Query被调用之前，返回错误给调用者。
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// 如果驱动不知道占位符的个数，NumInput可能会返回-1。在这种情况下，
</span><span class="c1"></span>	<span class="c1">// sql包将不会检查Exec和Query的参数个数
</span><span class="c1"></span>	<span class="nf">NumInput</span><span class="p">()</span> <span class="kt">int</span>

	<span class="c1">// Exec执行一个不返回数据行的查询，比如INSERT或UPDATE
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// 弃用：驱动应实现StmtExecContext来替代
</span><span class="c1"></span>	<span class="nf">Exec</span><span class="p">(</span><span class="nx">args</span> <span class="p">[]</span><span class="nx">Value</span><span class="p">)</span> <span class="p">(</span><span class="nx">Result</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

	<span class="c1">// Query执行一个返回数据行的查询，比如SELECT
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// 弃用：驱动应实现StmtQueryContext来替代
</span><span class="c1"></span>	<span class="nf">Query</span><span class="p">(</span><span class="nx">args</span> <span class="p">[]</span><span class="nx">Value</span><span class="p">)</span> <span class="p">(</span><span class="nx">Rows</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// StmtExecContext升级了Stmt接口，它提供了一个有context的Exec，
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">StmtExecContext</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// ExecContext执行一个不返回数据行的查询，比如INSERT或UPDATE
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// ExecContext必须遵守context超时，当context被取消时，函数需要返回
</span><span class="c1"></span>	<span class="nf">ExecContext</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">args</span> <span class="p">[]</span><span class="nx">NamedValue</span><span class="p">)</span> <span class="p">(</span><span class="nx">Result</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// StmtQueryContext升级了Stmt接口，它提供了一个有context的Query
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">StmtQueryContext</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// QueryContext执行一个返回数据行的查询，比如SELECT
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// ExecContext必须遵守context超时，当context被取消时，函数需要返回
</span><span class="c1"></span>	<span class="nf">QueryContext</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">args</span> <span class="p">[]</span><span class="nx">NamedValue</span><span class="p">)</span> <span class="p">(</span><span class="nx">Rows</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// ErrRemoveArgument可能被NamedValueChecker返回，用来指示sql包不要
</span><span class="c1">// 给驱动的query接口传递这个参数。
</span><span class="c1">// 当接收到不是查询参数的特定属性或结构时，返回该错误
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">ErrRemoveArgument</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;driver: remove argument from query&#34;</span><span class="p">)</span>

<span class="c1">// Conn或Stmt可选择是否要实现NamedValueChecker接口。接口提供给驱动
</span><span class="c1">// 更多的控制，去处理超出Go和数据库允许的默认值类型。
</span><span class="c1">//
</span><span class="c1">// 对于值的检查对象，sql包按如下顺序进行检查。当第一次发现匹配时停止：
</span><span class="c1">// Stmt.NamedValueChecker, Conn.NamedValueChecker, Stmt.ColumnConverter,
</span><span class="c1">// DefaultParameterConverter.
</span><span class="c1">//
</span><span class="c1">// 如果CheckNamedValue返回ErrRemoveArgument错误，那么这个NamedValue将不会
</span><span class="c1">// 被包含在最终的查询参数中。这可能会被用于给查询传递特殊的选项。
</span><span class="c1">//
</span><span class="c1">// 如果ErrSkip错误被返回，则使用列转换器错误检查路径作为参数。
</span><span class="c1">// 驱动可能希望在耗尽自己特殊case后返回ErrSkip
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">NamedValueChecker</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// 在传递参数给驱动之前，CheckNamedValue会被调用。
</span><span class="c1"></span>	<span class="c1">// 在任何ColumnConverter的地方也会调用CheckNamedValue。
</span><span class="c1"></span>	<span class="c1">// CheckNamedValue必须根据驱动的需要做类型校验和转换
</span><span class="c1"></span>	<span class="nf">CheckNamedValue</span><span class="p">(</span><span class="o">*</span><span class="nx">NamedValue</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>

<span class="c1">// 如果语句知道自己列的类型，并且能够从任何类型转换为驱动的Value，
</span><span class="c1">// 那么Stmt 可以选择性的实现ColumnConverter
</span><span class="c1">// 
</span><span class="c1">// 弃用：驱动应实现NamedValueChecker
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ColumnConverter</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// 根据提供的列序号，ColumnConverter返回一个 ValueConverter。
</span><span class="c1"></span>	<span class="c1">// 如果该列是未知的或者不需要被特殊处理，方法返回DefaultValueConverter
</span><span class="c1"></span>	<span class="nf">ColumnConverter</span><span class="p">(</span><span class="nx">idx</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">ValueConverter</span>
<span class="p">}</span>

<span class="c1">// Rows是一个查询结果的迭代器
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Rows</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// Columns返回列的名字集，它的个数是从slice的长度中推断出来的。
</span><span class="c1"></span>	<span class="c1">// 如果不知道特定的列名，应该为该条目返回一个空的字符串
</span><span class="c1"></span>	<span class="nf">Columns</span><span class="p">()</span> <span class="p">[]</span><span class="kt">string</span>

	<span class="c1">// 关闭行迭代器
</span><span class="c1"></span>	<span class="nf">Close</span><span class="p">()</span> <span class="kt">error</span>

	<span class="c1">// Next用于把数据集中的下一行填入提供的slice中。该slice的
</span><span class="c1"></span>	<span class="c1">// 长度应该跟Columns()的长度一致
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// 当没有数据行时，Next应该返回io.EOF
</span><span class="c1"></span>	<span class="c1">// 
</span><span class="c1"></span>	<span class="c1">// dest不应被声明在Next之外(应该作为Next的一个成员变量)
</span><span class="c1"></span>	<span class="c1">// 关闭Rows时应特别注意，不要修改dest中缓冲区的值
</span><span class="c1"></span>	<span class="nf">Next</span><span class="p">(</span><span class="nx">dest</span> <span class="p">[]</span><span class="nx">Value</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>

<span class="c1">// RowsNextResultSet扩展了Rows接口，它提供了一个方式，让驱动向前移动
</span><span class="c1">// 到下一个结果集
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">RowsNextResultSet</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Rows</span>

	<span class="c1">// 在当前结果集的末尾调用HasNextResultSet，报告当前结果集之后是否还存在
</span><span class="c1"></span>	<span class="c1">// 别的结果集
</span><span class="c1"></span>	<span class="nf">HasNextResultSet</span><span class="p">()</span> <span class="kt">bool</span>

	<span class="c1">// NextResultSet向前移动驱动到下一个结果集，即使当前结果集
</span><span class="c1"></span>	<span class="c1">// 仍然存在剩余的数据行
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// 当不再有数据集时，NextResultSet应该返回io.EOF
</span><span class="c1"></span>	<span class="nf">NextResultSet</span><span class="p">()</span> <span class="kt">error</span>
<span class="p">}</span>

<span class="c1">// RowsColumnTypeScanType可以通过Rows实现，它应该返回可用于扫描的数据类型。
</span><span class="c1">// 比如，数据库的列类型`bigint`应该返回&#34;reflect.TypeOf(int64(0))&#34;.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">RowsColumnTypeScanType</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Rows</span>
	<span class="nf">ColumnTypeScanType</span><span class="p">(</span><span class="nx">index</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Type</span>
<span class="p">}</span>

<span class="c1">// RowsColumnTypeDatabaseTypeName可以通过Rows实现。它应该返回不包括字段长度的数据库类型，
</span><span class="c1">// 类型名应该全大写。诸如：&#34;VARCHAR&#34;, &#34;NVARCHAR&#34;, &#34;VARCHAR2&#34;, &#34;CHAR&#34;, &#34;TEXT&#34;,
</span><span class="c1">// &#34;DECIMAL&#34;, &#34;SMALLINT&#34;, &#34;INT&#34;, &#34;BIGINT&#34;, &#34;BOOL&#34;, &#34;[]BIGINT&#34;, &#34;JSONB&#34;, &#34;XML&#34;,
</span><span class="c1">// &#34;TIMESTAMP&#34;.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">RowsColumnTypeDatabaseTypeName</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Rows</span>
	<span class="nf">ColumnTypeDatabaseTypeName</span><span class="p">(</span><span class="nx">index</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c1">// RowsColumnTypeLength可以通过Rows实现，如果列是可变长度的类型，它应该返回
</span><span class="c1">// 类型的长度。如果列是不可变长度的类型，ok返回false。
</span><span class="c1">// 如果类型长度只受系统限制，则应该返回math.MaxInt64
</span><span class="c1">// 下面是变量类型的返回值示例
</span><span class="c1">//   TEXT          (math.MaxInt64, true)
</span><span class="c1">//   varchar(10)   (10, true)
</span><span class="c1">//   nvarchar(10)  (10, true)
</span><span class="c1">//   decimal       (0, false)
</span><span class="c1">//   int           (0, false)
</span><span class="c1">//   bytea(30)     (30, true)
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">RowsColumnTypeLength</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Rows</span>
	<span class="nf">ColumnTypeLength</span><span class="p">(</span><span class="nx">index</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">length</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// RowsColumnTypeNullable可以通过Rows实现。如果指定的列可以为空，则nullable
</span><span class="c1">// 返回true。相反，如果列不能为空，nullable应该返回false。
</span><span class="c1">// 如果不知道该列是否可以为空，ok应该返回false
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">RowsColumnTypeNullable</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Rows</span>
	<span class="nf">ColumnTypeNullable</span><span class="p">(</span><span class="nx">index</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">nullable</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// RowsColumnTypePrecisionScale可以被Rows实现，对于decimal类型，它应该返回
</span><span class="c1">// 精度和小数点右边的范围。如果类型不适用，ok应返回false
</span><span class="c1">// 下面是不同类型的返回值示例：
</span><span class="c1">//   decimal(38, 4)    (38, 4, true)
</span><span class="c1">//   int               (0, 0, false)
</span><span class="c1">//   decimal           (math.MaxInt64, math.MaxInt64, true)
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">RowsColumnTypePrecisionScale</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Rows</span>
	<span class="nf">ColumnTypePrecisionScale</span><span class="p">(</span><span class="nx">index</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">precision</span><span class="p">,</span> <span class="nx">scale</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Tx是一个事务
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Tx</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Commit</span><span class="p">()</span> <span class="kt">error</span>
	<span class="nf">Rollback</span><span class="p">()</span> <span class="kt">error</span>
<span class="p">}</span>

<span class="c1">// RowsAffected实现了INSERT或UPDATE操作的结果
</span><span class="c1">// 表示被影响的行数
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">RowsAffected</span> <span class="kt">int64</span>

<span class="kd">var</span> <span class="nx">_</span> <span class="nx">Result</span> <span class="p">=</span> <span class="nf">RowsAffected</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">RowsAffected</span><span class="p">)</span> <span class="nf">LastInsertId</span><span class="p">()</span> <span class="p">(</span><span class="kt">int64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;LastInsertId is not supported by this driver&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">RowsAffected</span><span class="p">)</span> <span class="nf">RowsAffected</span><span class="p">()</span> <span class="p">(</span><span class="kt">int64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">v</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// ResultNoRows是一个预定义的结果，在一个DDL操作(比如CREATE TABLE)执行成功
</span><span class="c1">// 时返回。调用该类型的LastInsertId和LastInsertId方法会返回错误
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">ResultNoRows</span> <span class="nx">noRows</span>

<span class="kd">type</span> <span class="nx">noRows</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">var</span> <span class="nx">_</span> <span class="nx">Result</span> <span class="p">=</span> <span class="nx">noRows</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">noRows</span><span class="p">)</span> <span class="nf">LastInsertId</span><span class="p">()</span> <span class="p">(</span><span class="kt">int64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;no LastInsertId available after DDL statement&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">noRows</span><span class="p">)</span> <span class="nf">RowsAffected</span><span class="p">()</span> <span class="p">(</span><span class="kt">int64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;no RowsAffected available after DDL statement&#34;</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
  </section>

  <section>
    
      
    
  </section>
</article>

      </div>

      <div id="side" class="pr-1 bg-white">
        <aside class="pr-3">
          
  
    <div id="toc" class="Box Box--blue mb-3">
      <b>database.sql.driver</b></div>
  

  
    <div>
      
    </div>
  

        </aside>
      </div>

      <div id="footer" class="pt-2 pb-3 bg-white text-center">
        

  <span class="text-small text-gray">
    &copy;Qiushi Pan 2018-2019 &middot; 

    Powered by the
    <a href="https://github.com/qqhann/hugo-primer" class="link-gray-dark">Hugo-Primer</a> theme for
    <a href="https://gohugo.io" class="link-gray-dark">Hugo</a>.
  </span>


      </div>
    </div>

    
    
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });</script>
    
  </body>
</html>
