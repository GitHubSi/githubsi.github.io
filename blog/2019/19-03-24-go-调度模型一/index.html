<!DOCTYPE html>
<html>
  <head>
    
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-12345678-0', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
  Go 调度模型（一） &ndash; 渐行渐远

    </title>
    
    
    <meta name="description" property="og:description" content="想清楚了就去做，做的时候不要再回头想。 OS Scheduler 在操作系统中保存了运行的进程列表，以及进程的运行状态(运行中、可运行及不可运行)。当进程运行时长超|Hugo-Primer theme&#39;s example site">
    

    <meta name="apple-mobile-web-app-title" content="渐行渐远">
    
    
    
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@">
    <meta name="twitter:creator" content="@">
    <meta name="twitter:title" content="Go 调度模型（一） | 渐行渐远">
    <meta name="twitter:description" content="想清楚了就去做，做的时候不要再回头想。 OS Scheduler 在操作系统中保存了运行的进程列表，以及进程的运行状态(运行中、可运行及不可运行)。当进程运行时长超|Hugo-Primer theme&#39;s example site">
    <meta name="twitter:image" content="https://gohugo.io/twitter-card.png">
    


    <link rel="stylesheet" href="/assets/syntax.css">
    <link rel="stylesheet" href="/assets/primer-build.css">
    <link rel="stylesheet" href="/assets/style.css">
  </head>


  <body class="bg-gray">
    <div id="holy" class="container-lg bg-white h-100">

      <div id="header" class="px-1 bg-white">
        <nav class="UnderlineNav UnderlineNav--right px-2">
  <a class="UnderlineNav-actions muted-link h2" href="https://gohugo.io/">
    渐行渐远
  </a>

  
  
</nav>

      </div>

      <div role="main" id="main" class="holy-main markdown-body px-4 bg-white">
        

<div class="Subhead">
  <div class="Subhead-heading">
    <div class="h1 mt-3 mb-1">Go 调度模型（一）</div>
  </div>
  <div class="Subhead-description">
    




<a href='/tags/translate' class="muted-link">
  <span class="Label Label--gray">translate</span>
</a>

<a href='/tags/golang' class="muted-link">
  <span class="Label Label--gray">golang</span>
</a>



    
    <div class="float-md-right">
      <span title="Lastmod: 2019-03-24. Published at: 2019-03-24.">
        
          Published: 2019-03-24
        
      </span>
    </div>
    
  </div>
</div>
<article>
  
  <section class="pb-6 mb-3 border-bottom">
    

<blockquote>
<p><code>想清楚了就去做，做的时候不要再回头想。</code></p>
</blockquote>

<h2 id="os-scheduler"><code>OS Scheduler</code></h2>

<p>在操作系统中保存了运行的进程列表，以及进程的运行状态(运行中、可运行及不可运行)。当进程运行时长超过了被分配的时间片(比如每10<code>ms</code>)，那么该进程会被系统抢占，然后在该<code>CPU</code>上执行别的进程。所以，<code>OS</code>的调度是抢占式的，可能抢占策略略有不同。</p>

<p>当进程被抢占时，需要保存该进程运行的上下文，并被重新放回到调度器，等待下一次被执行。</p>

<h2 id="golang-scheduler">Golang Scheduler</h2>

<blockquote>
<p>Goroutine scheduler</p>

<p>The scheduler&rsquo;s job is to distribute ready-to-run goroutines over worker threads.</p>
</blockquote>

<p>如图所示，<code>OS</code>层看到是只有<code>Go</code>进程以及运行的多个线程，而<code>Goroutine</code>本身是被<code>Golang Runtime Scheduler</code>调度管理的。</p>

<p>对<code>OS</code>而言，<code>Go Binary</code>是一个系统进程。内部<code>Go Program</code>对系统<code>API</code>的调度都是通过<code>Runtime level</code>解释来实现。<code>Runtine</code>记录了每个<code>Goroutine</code>的信息，在当前进程的线程池中按照顺序依次调度<code>Goroutine</code>。</p>

<p><img src="https://i.loli.net/2019/03/24/5c974c7eb3407.png" alt="`Diagram of the relationships between the
runtime, OS, and programmer defined code`" /></p>

<p><code>Golang</code>在<code>Runtime</code>内部实现了自己的调度，并不是基于时间切片的抢占式调度，而是基于<code>Goroutines</code>的协作式调度，目的就是要让<code>Goroutine</code>在<code>OS-Thread</code>中发挥出更多的并发优势。所以，在<code>Runtime</code>过程中，只有当正在运行的<code>Goroutine</code>被阻塞或者运行结束时，别的<code>Goroutine</code>才会被调度。常见的阻塞情形包括：</p>

<ul>
<li>阻塞的系统调用方式，比如文件或网络操作</li>
<li>垃圾自动回收</li>
</ul>

<p>整体而言，<code>Goroutine</code>的数量大于<code>Threads</code>数量会更有优势，这样当其他<code>Goroutine</code>阻塞时，别的<code>Goroutine</code>就会被执行。</p>

<h2 id="goroutine">Goroutine</h2>

<p><code>G</code>用于表示<code>Goroutine</code>及它所包含的栈和状态信息。<code>Goroutine</code>存在于<code>Go Runtime</code>的的虚拟空间，而非<code>OS</code>中。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/runtime2.go
</span><span class="c1">// 以下结构体精简了很多字段
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">g</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">stack</span>       <span class="nx">stack</span>   <span class="c1">// offset known to runtime/cgo
</span><span class="c1"></span>
	<span class="nx">m</span>              <span class="o">*</span><span class="nx">m</span>      <span class="c1">// current m; offset known to arm liblink
</span><span class="c1"></span>	<span class="nx">sched</span>          <span class="nx">gobuf</span>
	<span class="nx">stktopsp</span>       <span class="kt">uintptr</span>        <span class="c1">// expected sp at top of stack, to check in traceback
</span><span class="c1"></span>	<span class="nx">param</span>          <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// passed parameter on wakeup
</span><span class="c1"></span>	<span class="nx">atomicstatus</span>   <span class="kt">uint32</span>
	<span class="nx">stackLock</span>      <span class="kt">uint32</span> <span class="c1">// sigprof/scang lock; TODO: fold in to atomicstatus
</span><span class="c1"></span><span class="p">}</span></code></pre></div>
<p>代码中，通过追加<code>go</code>前缀遍可以创建<code>groutine</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="kd">func</span><span class="p">(){</span>
<span class="p">}</span></code></pre></div>
<h2 id="machine"><code>Machine</code></h2>

<p>物理执行的单元，用于表示<code>OS Threads</code>。<code>M</code>包含当前运行的<code>Goroutine</code>信息等。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/runtime2.go
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">m</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">g0</span>      <span class="o">*</span><span class="nx">g</span>     <span class="c1">// goroutine with scheduling stack
</span><span class="c1"></span>	
	<span class="c1">// Fields not known to debuggers.
</span><span class="c1"></span>	<span class="nx">goSigStack</span>    <span class="nx">gsignalStack</span> <span class="c1">// Go-allocated signal handling stack
</span><span class="c1"></span>	<span class="nx">curg</span>          <span class="o">*</span><span class="nx">g</span>       <span class="c1">// current running goroutine
</span><span class="c1"></span>	<span class="nx">p</span>             <span class="nx">puintptr</span> <span class="c1">// attached p for executing go code (nil if not executing go code)
</span><span class="c1"></span>	<span class="nx">spinning</span>      <span class="kt">bool</span> <span class="c1">// m is out of work and is actively looking for work
</span><span class="c1"></span>	<span class="nx">blocked</span>       <span class="kt">bool</span> <span class="c1">// m is blocked on a note
</span><span class="c1"></span>	<span class="nx">freeWait</span>      <span class="kt">uint32</span> <span class="c1">// if == 0, safe to free g0 and delete m (atomic)
</span><span class="c1"></span>	<span class="nx">alllink</span>       <span class="o">*</span><span class="nx">m</span> <span class="c1">// on allm
</span><span class="c1"></span>	<span class="nx">schedlink</span>     <span class="nx">muintptr</span>
	<span class="nx">createstack</span>   <span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="kt">uintptr</span>    <span class="c1">// stack that created this thread.
</span><span class="c1"></span>	<span class="nx">thread</span>        <span class="kt">uintptr</span> <span class="c1">// thread handle
</span><span class="c1"></span>	<span class="nx">freelink</span>      <span class="o">*</span><span class="nx">m</span>      <span class="c1">// on sched.freem
</span><span class="c1"></span><span class="p">}</span></code></pre></div>
<h2 id="processor"><code>Processor</code></h2>

<p><code>P</code>记录了<code>G</code>和<code>M</code>的相关信息，<code>P</code>需要调度<code>M</code>来让<code>M</code>执行<code>G</code>的代码。在<code>P</code>中包含了本地可运行的<code>Goroutine</code>队列，这样的设计也是为了优化访问全局<code>Goroutines</code>队列频繁加锁的性能问题。当一个新的<code>G</code>被创建，它会被追加在相应<code>P</code>队列的末尾，以保证最终会被执行。</p>

<p>此外，当<code>P</code>没有可运行的<code>Goroutine</code>处理时，它会随机从其他<code>P</code>的<code>Goroutines</code>队列末尾取一半<code>G</code>用于自己消费。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/runtime2.go
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">p</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">lock</span> <span class="nx">mutex</span>

	<span class="nx">id</span>          <span class="kt">int32</span>
	<span class="nx">m</span>           <span class="nx">muintptr</span>   <span class="c1">// back-link to associated m (nil if idle)
</span><span class="c1"></span>	<span class="nx">mcache</span>      <span class="o">*</span><span class="nx">mcache</span>

	<span class="c1">// Queue of runnable goroutines. Accessed without lock.
</span><span class="c1"></span>	<span class="nx">runqhead</span> <span class="kt">uint32</span>
	<span class="nx">runqtail</span> <span class="kt">uint32</span>
	<span class="nx">runq</span>     <span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="nx">guintptr</span>
	<span class="c1">// runnext, if non-nil, is a runnable G that was ready&#39;d by
</span><span class="c1"></span>	<span class="c1">// the current G and should be run next instead of what&#39;s in
</span><span class="c1"></span>	<span class="c1">// runq if there&#39;s time remaining in the running G&#39;s time
</span><span class="c1"></span>	<span class="c1">// slice. It will inherit the time left in the current time
</span><span class="c1"></span>	<span class="c1">// slice. If a set of goroutines is locked in a
</span><span class="c1"></span>	<span class="c1">// communicate-and-wait pattern, this schedules that set as a
</span><span class="c1"></span>	<span class="c1">// unit and eliminates the (potentially large) scheduling
</span><span class="c1"></span>	<span class="c1">// latency that otherwise arises from adding the ready&#39;d
</span><span class="c1"></span>	<span class="c1">// goroutines to the end of the run queue.
</span><span class="c1"></span>	<span class="nx">runnext</span> <span class="nx">guintptr</span>

	<span class="c1">// Available G&#39;s (status == Gdead)
</span><span class="c1"></span>	<span class="nx">gfree</span>    <span class="o">*</span><span class="nx">g</span>
<span class="p">}</span></code></pre></div>
<h2 id="code-snippet"><code>Code snippet</code></h2>

<p>尝试执行下面的代码，会发现这其实是一个死循环，最后的打印结果永远得不到输出。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
<span class="kn">import</span> <span class="s">&#34;time&#34;</span>
<span class="kn">import</span> <span class="s">&#34;runtime&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">result</span> <span class="kt">int</span>
    <span class="nx">processors</span> <span class="o">:=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">processors</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">{</span> <span class="nx">result</span><span class="o">++</span> <span class="p">}</span>
        <span class="p">}()</span>
    <span class="p">}</span>
    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>       <span class="c1">//wait for go function to increment the value.
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;result =&#34;</span><span class="p">,</span> <span class="nx">result</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>在<code>Golang</code>运行时，创建的<code>OS Threads</code>最多等于<code>GOMAXPROCS</code>，<code>Goroutine</code>就在这有限的<code>OS Threads</code>上被调度执行。</p>

<p>在代码中，当前并行运行的<code>Goroutine</code>全部用来做无限循环的累加操作，运行数量等于<code>GOMAXPROCS</code>。而<code>main</code>是一个额外的<code>Goroutine</code>。根据<code>Golang Scheduler</code>的设定，因为其他<code>Goroutine</code>都在紧张的运行，调度器并不会将其中的任何一个<code>Goroutine</code>挂起，所以<code>main goroutine</code>永远不会被调度执行。</p>

<p>在实际开发中，因为存在诸如<code>channel</code>或者<code>Api requeest</code>等情况，程序<code>hang</code>住的可能行并不大。</p>

<hr />

<p>参考文章：</p>

<ol>
<li><a href="https://medium.com/@riteeksrivastava/a-complete-journey-with-goroutines-8472630c7f5c"><code>A complete journey with Goroutines</code></a></li>
<li><a href="http://www.sarathlakshman.com/2016/06/15/pitfall-of-golang-scheduler"><code>A pitfall of golang scheduler</code></a></li>
<li><a href="http://www1.cs.columbia.edu/~aho/cs6998/reports/12-12-11_DeshpandeSponslerWeiss_GO.pdf"><code>Analysis of the Go runtime scheduler</code></a></li>
</ol>

  </section>

  <section>
    
      
    
  </section>
</article>

      </div>

      <div id="side" class="pr-1 bg-white">
        <aside class="pr-3">
          
  
    <div id="toc" class="Box Box--blue mb-3">
      <b>Go 调度模型（一）</b><nav id="TableOfContents"><ul>
<li><a href="#os-scheduler"><code>OS Scheduler</code></a></li>
<li><a href="#golang-scheduler">Golang Scheduler</a></li>
<li><a href="#goroutine">Goroutine</a></li>
<li><a href="#machine"><code>Machine</code></a></li>
<li><a href="#processor"><code>Processor</code></a></li>
<li><a href="#code-snippet"><code>Code snippet</code></a></li>
</ul></li>
</ul>
</nav></div>
  

  
    <div>
      
    </div>
  

        </aside>
      </div>

      <div id="footer" class="pt-2 pb-3 bg-white text-center">
        

  <span class="text-small text-gray">
    &copy;Qiushi Pan 2018-2019 &middot; 

    Powered by the
    <a href="https://github.com/qqhann/hugo-primer" class="link-gray-dark">Hugo-Primer</a> theme for
    <a href="https://gohugo.io" class="link-gray-dark">Hugo</a>.
  </span>


      </div>
    </div>

    
    
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });</script>
    
  </body>
</html>
