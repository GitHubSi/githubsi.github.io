<!DOCTYPE html>
<html>

<head>
    
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer">

<meta name="description" content="Hugo-Primer theme&#39;s example site">
<title>
    runtime中P的理解 - 渐行渐远
</title>









<link rel="stylesheet" href="/css/main.min.ea2156633063385371d7a4d9db559868e643a3885ab887da32f7ea8a1e05ee11.css" integrity="sha256-6iFWYzBjOFNx16TZ21WYaOZDo4hauIfaMvfqih4F7hE=" crossorigin="anonymous" media="screen">





<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic">
<script
        src="https://code.jquery.com/jquery-3.5.1.min.js"
        integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0="
        crossorigin="anonymous"></script>

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="runtime中P的理解"/>
<meta name="twitter:description" content="P是在Go1.1引入的概念，初始默认等于CPU核的数量。P只是一个逻辑概念，跟CPU也没有任何关系。 源码go/1.13.4/libexec/"/>

<meta property="og:title" content="runtime中P的理解" />
<meta property="og:description" content="P是在Go1.1引入的概念，初始默认等于CPU核的数量。P只是一个逻辑概念，跟CPU也没有任何关系。 源码go/1.13.4/libexec/" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://neojos.com/blog/2019/blog.014-runtime%E4%B8%ADp%E7%9A%84%E7%90%86%E8%A7%A3.2019.11.11/" />
<meta property="article:published_time" content="2019-11-11T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2019-11-11T00:00:00&#43;00:00"/>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-12345678-0', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

    

    
    
    
    <title>
        
        runtime中P的理解
        
    </title>
</head>

<body>

    
    
    <header class="text-center container">
        <h1 class="mb-4 mt-2">runtime中P的理解</h1>
    </header>
    
    <main class="wrap">
        
<div class="container">
    <aside role="complementary">
        <div class="tag-container">
            
            
            <span class="tag">
                <a href="/tags/golang/" class="badge badge-success">
                    golang
                </a>
            </span>
            
            
        </div>
        <div class="float-right badge badge-light">11-11-2019 &#183; 879 words</div>
    </aside>
    <hr />
    <article role="article">
        <p><code>P</code>是在<code>Go1.1</code>引入的概念，初始默认等于<code>CPU</code>核的数量。<code>P</code>只是一个逻辑概念，跟<code>CPU</code>也没有任何关系。</p>

<p>源码<code>go/1.13.4/libexec/src/runtime/proc.go</code>中对<code>P</code>的注释如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// P - processor, a resource that is required to execute Go code.
</span><span class="c1">// M must have an associated P to execute Go code, however it can be
</span><span class="c1"></span><span class="o">//</span> <span class="nx">blocked</span> <span class="nx">or</span> <span class="nx">in</span> <span class="nx">a</span> <span class="nx">syscall</span> <span class="nx">w</span><span class="o">/</span><span class="nx">o</span> <span class="nx">an</span> <span class="nx">associated</span> <span class="nx">P</span><span class="p">.</span></code></pre></div>
<p>再通过源码<code>go/1.13.4/libexec/src/runtime/runtime2.go</code>来简要了解一下<code>P</code>在调度过程中的状态变化：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
    <span class="c1">// P status
</span><span class="c1"></span>    <span class="nx">_Pidle</span> <span class="p">=</span> <span class="kc">iota</span>
    <span class="nx">_Prunning</span>
    <span class="nx">_Psyscall</span>
    <span class="nx">_Pgcstop</span>
   
    <span class="c1">// _Pdead means a P is no longer used (GOMAXPROCS shrank). We
</span><span class="c1"></span>    <span class="c1">// reuse Ps if GOMAXPROCS increases. A dead P is mostly
</span><span class="c1"></span>    <span class="c1">// stripped of its resources, though a few things remain
</span><span class="c1"></span>    <span class="c1">// (e.g., trace buffers).
</span><span class="c1"></span>    <span class="nx">_Pdead</span>
<span class="p">)</span></code></pre></div>
<p>通过调整<code>GOMAXPROCS</code>可以控制<code>P</code>的状态，<code>_Pdead</code>专门来说明这一点。</p>

<p>从<code>P</code>的结构体字段中，可以进一步了解<code>P</code>中存储的资源，源码<code>go/1.13.4/libexec/src/runtime/runtime2.go</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">p</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">id</span>          <span class="kt">int32</span>
        <span class="nx">status</span>      <span class="kt">uint32</span> <span class="c1">// one of pidle/prunning/...
</span><span class="c1"></span>        <span class="nx">link</span>        <span class="nx">puintptr</span>
        <span class="nx">schedtick</span>   <span class="kt">uint32</span>     <span class="c1">// incremented on every scheduler call
</span><span class="c1"></span>        <span class="nx">syscalltick</span> <span class="kt">uint32</span>     <span class="c1">// incremented on every system call
</span><span class="c1"></span>        <span class="nx">sysmontick</span>  <span class="nx">sysmontick</span> <span class="c1">// last tick observed by sysmon
</span><span class="c1"></span>        <span class="nx">m</span>           <span class="nx">muintptr</span>   <span class="c1">// back-link to associated m (nil if idle)
</span><span class="c1"></span>        <span class="nx">mcache</span>      <span class="o">*</span><span class="nx">mcache</span>
        <span class="nx">raceprocctx</span> <span class="kt">uintptr</span>

        <span class="nx">deferpool</span>    <span class="p">[</span><span class="mi">5</span><span class="p">][]</span><span class="o">*</span><span class="nx">_defer</span> <span class="c1">// pool of available defer structs of different sizes (see panic.go)
</span><span class="c1"></span>        <span class="nx">deferpoolbuf</span> <span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">32</span><span class="p">]</span><span class="o">*</span><span class="nx">_defer</span>

        <span class="c1">// Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.
</span><span class="c1"></span>        <span class="nx">goidcache</span>    <span class="kt">uint64</span>
        <span class="nx">goidcacheend</span> <span class="kt">uint64</span>

        <span class="c1">// Queue of runnable goroutines. Accessed without lock.
</span><span class="c1"></span>        <span class="nx">runqhead</span> <span class="kt">uint32</span>
        <span class="nx">runqtail</span> <span class="kt">uint32</span>
        <span class="nx">runq</span>     <span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="nx">guintptr</span>
        <span class="c1">// runnext, if non-nil, is a runnable G that was ready&#39;d by
</span><span class="c1"></span>        <span class="c1">// the current G and should be run next instead of what&#39;s in
</span><span class="c1"></span>        <span class="c1">// runq if there&#39;s time remaining in the running G&#39;s time
</span><span class="c1"></span>        <span class="c1">// slice. It will inherit the time left in the current time
</span><span class="c1"></span>        <span class="c1">// slice. If a set of goroutines is locked in a
</span><span class="c1"></span>        <span class="c1">// communicate-and-wait pattern, this schedules that set as a
</span><span class="c1"></span>        <span class="c1">// unit and eliminates the (potentially large) scheduling
</span><span class="c1"></span>        <span class="c1">// latency that otherwise arises from adding the ready&#39;d
</span><span class="c1"></span>        <span class="c1">// goroutines to the end of the run queue.
</span><span class="c1"></span>        <span class="nx">runnext</span> <span class="nx">guintptr</span>

        <span class="c1">// Available G&#39;s (status == Gdead)
</span><span class="c1"></span>        <span class="nx">gFree</span> <span class="kd">struct</span> <span class="p">{</span>
                <span class="nx">gList</span>
                <span class="nx">n</span> <span class="kt">int32</span>
        <span class="p">}</span>

        <span class="nx">sudogcache</span> <span class="p">[]</span><span class="o">*</span><span class="nx">sudog</span>
        <span class="nx">sudogbuf</span>   <span class="p">[</span><span class="mi">128</span><span class="p">]</span><span class="o">*</span><span class="nx">sudog</span>

        <span class="nx">tracebuf</span> <span class="nx">traceBufPtr</span>
         <span class="c1">// traceSweep indicates the sweep events should be traced.
</span><span class="c1"></span>        <span class="c1">// This is used to defer the sweep start event until a span
</span><span class="c1"></span>        <span class="c1">// has actually been swept.
</span><span class="c1"></span>        <span class="nx">traceSweep</span> <span class="kt">bool</span>
        <span class="c1">// traceSwept and traceReclaimed track the number of bytes
</span><span class="c1"></span>        <span class="c1">// swept and reclaimed by sweeping in the current sweep loop.
</span><span class="c1"></span>        <span class="nx">traceSwept</span><span class="p">,</span> <span class="nx">traceReclaimed</span> <span class="kt">uintptr</span>

        <span class="nx">palloc</span> <span class="nx">persistentAlloc</span> <span class="c1">// per-P to avoid mutex
</span><span class="c1"></span>
        <span class="nx">_</span> <span class="kt">uint32</span> <span class="c1">// Alignment for atomic fields below
</span><span class="c1"></span>
        <span class="c1">// Per-P GC state
</span><span class="c1"></span>        <span class="nx">gcAssistTime</span>         <span class="kt">int64</span>    <span class="c1">// Nanoseconds in assistAlloc
</span><span class="c1"></span>        <span class="nx">gcFractionalMarkTime</span> <span class="kt">int64</span>    <span class="c1">// Nanoseconds in fractional mark worker (atomic)
</span><span class="c1"></span>        <span class="nx">gcBgMarkWorker</span>       <span class="nx">guintptr</span> <span class="c1">// (atomic)
</span><span class="c1"></span>        <span class="nx">gcMarkWorkerMode</span>     <span class="nx">gcMarkWorkerMode</span>

        <span class="c1">// gcMarkWorkerStartTime is the nanotime() at which this mark
</span><span class="c1"></span>        <span class="c1">// worker started.
</span><span class="c1"></span>        <span class="nx">gcMarkWorkerStartTime</span> <span class="kt">int64</span>

        <span class="c1">// gcw is this P&#39;s GC work buffer cache. The work buffer is
</span><span class="c1"></span>        <span class="c1">// filled by write barriers, drained by mutator assists, and
</span><span class="c1"></span>        <span class="c1">// disposed on certain GC state transitions.
</span><span class="c1"></span>        <span class="nx">gcw</span> <span class="nx">gcWork</span>

        <span class="c1">// wbBuf is this P&#39;s GC write barrier buffer.
</span><span class="c1"></span>        <span class="c1">//
</span><span class="c1"></span>        <span class="c1">// TODO: Consider caching this in the running G.
</span><span class="c1"></span>        <span class="nx">wbBuf</span> <span class="nx">wbBuf</span>

        <span class="nx">runSafePointFn</span> <span class="kt">uint32</span> <span class="c1">// if 1, run sched.safePointFn at next safe point
</span><span class="c1"></span>
        <span class="nx">pad</span> <span class="nx">cpu</span><span class="p">.</span><span class="nx">CacheLinePad</span>
<span class="p">}</span></code></pre></div>
<p>字段中<code>mcache</code>再单独说明一下，源码<code>go/1.13.4/libexec/src/runtime/mcache.go</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Per-thread (in Go, per-P) cache for small objects.
</span><span class="c1">// No locking needed because it is per-thread (per-P).
</span><span class="c1">//
</span><span class="c1">// mcaches are allocated from non-GC&#39;d memory, so any heap pointers
</span><span class="c1">// must be specially handled.
</span><span class="c1">//
</span><span class="c1"></span><span class="o">//</span><span class="k">go</span><span class="p">:</span><span class="nx">notinheap</span></code></pre></div>
<p><code>mcache</code>反映了对象的创建策略：小对象。</p>

    </article>
</div>


        
<nav role="navigation" class="bottom-menu">
    

    
        <a href="/blog">back</a>
        
    

    
</p>
</nav>

    </main>
    
    <footer class="container footer"></footer>
    
    
</body>

</html>