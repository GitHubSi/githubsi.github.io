<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>runtime中P的理解 - 渐行渐远</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">
	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="shortcut icon" href="/favicon.ico">
		
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-12345678-0', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="渐行渐远" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">渐行渐远</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">runtime中P的理解</h1>
			
		</header><div class="content post__content clearfix">
			<p><code>P</code>是在<code>Go1.1</code>引入的概念，初始默认等于<code>CPU</code>核的数量。<code>P</code>只是一个逻辑概念，跟<code>CPU</code>也没有任何关系。</p>
<p>源码<code>go/1.13.4/libexec/src/runtime/proc.go</code>中对<code>P</code>的注释如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// P - processor, a resource that is required to execute Go code.
</span><span class="c1">// M must have an associated P to execute Go code, however it can be
</span><span class="c1">// blocked or in a syscall w/o an associated P.
</span></code></pre></div><p>再通过源码<code>go/1.13.4/libexec/src/runtime/runtime2.go</code>来简要了解一下<code>P</code>在调度过程中的状态变化：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
    <span class="c1">// P status
</span><span class="c1"></span>    <span class="nx">_Pidle</span> <span class="p">=</span> <span class="kc">iota</span>
    <span class="nx">_Prunning</span>
    <span class="nx">_Psyscall</span>
    <span class="nx">_Pgcstop</span>
   
    <span class="c1">// _Pdead means a P is no longer used (GOMAXPROCS shrank). We
</span><span class="c1"></span>    <span class="c1">// reuse Ps if GOMAXPROCS increases. A dead P is mostly
</span><span class="c1"></span>    <span class="c1">// stripped of its resources, though a few things remain
</span><span class="c1"></span>    <span class="c1">// (e.g., trace buffers).
</span><span class="c1"></span>    <span class="nx">_Pdead</span>
<span class="p">)</span>
</code></pre></div><p>通过调整<code>GOMAXPROCS</code>可以控制<code>P</code>的状态，<code>_Pdead</code>专门来说明这一点。</p>
<p>从<code>P</code>的结构体字段中，可以进一步了解<code>P</code>中存储的资源，源码<code>go/1.13.4/libexec/src/runtime/runtime2.go</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">p</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">id</span>          <span class="kt">int32</span>
        <span class="nx">status</span>      <span class="kt">uint32</span> <span class="c1">// one of pidle/prunning/...
</span><span class="c1"></span>        <span class="nx">link</span>        <span class="nx">puintptr</span>
        <span class="nx">schedtick</span>   <span class="kt">uint32</span>     <span class="c1">// incremented on every scheduler call
</span><span class="c1"></span>        <span class="nx">syscalltick</span> <span class="kt">uint32</span>     <span class="c1">// incremented on every system call
</span><span class="c1"></span>        <span class="nx">sysmontick</span>  <span class="nx">sysmontick</span> <span class="c1">// last tick observed by sysmon
</span><span class="c1"></span>        <span class="nx">m</span>           <span class="nx">muintptr</span>   <span class="c1">// back-link to associated m (nil if idle)
</span><span class="c1"></span>        <span class="nx">mcache</span>      <span class="o">*</span><span class="nx">mcache</span>
        <span class="nx">raceprocctx</span> <span class="kt">uintptr</span>

        <span class="nx">deferpool</span>    <span class="p">[</span><span class="mi">5</span><span class="p">][]</span><span class="o">*</span><span class="nx">_defer</span> <span class="c1">// pool of available defer structs of different sizes (see panic.go)
</span><span class="c1"></span>        <span class="nx">deferpoolbuf</span> <span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">32</span><span class="p">]</span><span class="o">*</span><span class="nx">_defer</span>

        <span class="c1">// Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.
</span><span class="c1"></span>        <span class="nx">goidcache</span>    <span class="kt">uint64</span>
        <span class="nx">goidcacheend</span> <span class="kt">uint64</span>

        <span class="c1">// Queue of runnable goroutines. Accessed without lock.
</span><span class="c1"></span>        <span class="nx">runqhead</span> <span class="kt">uint32</span>
        <span class="nx">runqtail</span> <span class="kt">uint32</span>
        <span class="nx">runq</span>     <span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="nx">guintptr</span>
        <span class="c1">// runnext, if non-nil, is a runnable G that was ready&#39;d by
</span><span class="c1"></span>        <span class="c1">// the current G and should be run next instead of what&#39;s in
</span><span class="c1"></span>        <span class="c1">// runq if there&#39;s time remaining in the running G&#39;s time
</span><span class="c1"></span>        <span class="c1">// slice. It will inherit the time left in the current time
</span><span class="c1"></span>        <span class="c1">// slice. If a set of goroutines is locked in a
</span><span class="c1"></span>        <span class="c1">// communicate-and-wait pattern, this schedules that set as a
</span><span class="c1"></span>        <span class="c1">// unit and eliminates the (potentially large) scheduling
</span><span class="c1"></span>        <span class="c1">// latency that otherwise arises from adding the ready&#39;d
</span><span class="c1"></span>        <span class="c1">// goroutines to the end of the run queue.
</span><span class="c1"></span>        <span class="nx">runnext</span> <span class="nx">guintptr</span>

        <span class="c1">// Available G&#39;s (status == Gdead)
</span><span class="c1"></span>        <span class="nx">gFree</span> <span class="kd">struct</span> <span class="p">{</span>
                <span class="nx">gList</span>
                <span class="nx">n</span> <span class="kt">int32</span>
        <span class="p">}</span>

        <span class="nx">sudogcache</span> <span class="p">[]</span><span class="o">*</span><span class="nx">sudog</span>
        <span class="nx">sudogbuf</span>   <span class="p">[</span><span class="mi">128</span><span class="p">]</span><span class="o">*</span><span class="nx">sudog</span>

        <span class="nx">tracebuf</span> <span class="nx">traceBufPtr</span>
         <span class="c1">// traceSweep indicates the sweep events should be traced.
</span><span class="c1"></span>        <span class="c1">// This is used to defer the sweep start event until a span
</span><span class="c1"></span>        <span class="c1">// has actually been swept.
</span><span class="c1"></span>        <span class="nx">traceSweep</span> <span class="kt">bool</span>
        <span class="c1">// traceSwept and traceReclaimed track the number of bytes
</span><span class="c1"></span>        <span class="c1">// swept and reclaimed by sweeping in the current sweep loop.
</span><span class="c1"></span>        <span class="nx">traceSwept</span><span class="p">,</span> <span class="nx">traceReclaimed</span> <span class="kt">uintptr</span>

        <span class="nx">palloc</span> <span class="nx">persistentAlloc</span> <span class="c1">// per-P to avoid mutex
</span><span class="c1"></span>
        <span class="nx">_</span> <span class="kt">uint32</span> <span class="c1">// Alignment for atomic fields below
</span><span class="c1"></span>
        <span class="c1">// Per-P GC state
</span><span class="c1"></span>        <span class="nx">gcAssistTime</span>         <span class="kt">int64</span>    <span class="c1">// Nanoseconds in assistAlloc
</span><span class="c1"></span>        <span class="nx">gcFractionalMarkTime</span> <span class="kt">int64</span>    <span class="c1">// Nanoseconds in fractional mark worker (atomic)
</span><span class="c1"></span>        <span class="nx">gcBgMarkWorker</span>       <span class="nx">guintptr</span> <span class="c1">// (atomic)
</span><span class="c1"></span>        <span class="nx">gcMarkWorkerMode</span>     <span class="nx">gcMarkWorkerMode</span>

        <span class="c1">// gcMarkWorkerStartTime is the nanotime() at which this mark
</span><span class="c1"></span>        <span class="c1">// worker started.
</span><span class="c1"></span>        <span class="nx">gcMarkWorkerStartTime</span> <span class="kt">int64</span>

        <span class="c1">// gcw is this P&#39;s GC work buffer cache. The work buffer is
</span><span class="c1"></span>        <span class="c1">// filled by write barriers, drained by mutator assists, and
</span><span class="c1"></span>        <span class="c1">// disposed on certain GC state transitions.
</span><span class="c1"></span>        <span class="nx">gcw</span> <span class="nx">gcWork</span>

        <span class="c1">// wbBuf is this P&#39;s GC write barrier buffer.
</span><span class="c1"></span>        <span class="c1">//
</span><span class="c1"></span>        <span class="c1">// TODO: Consider caching this in the running G.
</span><span class="c1"></span>        <span class="nx">wbBuf</span> <span class="nx">wbBuf</span>

        <span class="nx">runSafePointFn</span> <span class="kt">uint32</span> <span class="c1">// if 1, run sched.safePointFn at next safe point
</span><span class="c1"></span>
        <span class="nx">pad</span> <span class="nx">cpu</span><span class="p">.</span><span class="nx">CacheLinePad</span>
<span class="p">}</span>
</code></pre></div><p>字段中<code>mcache</code>再单独说明一下，源码<code>go/1.13.4/libexec/src/runtime/mcache.go</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Per-thread (in Go, per-P) cache for small objects.
</span><span class="c1">// No locking needed because it is per-thread (per-P).
</span><span class="c1">//
</span><span class="c1">// mcaches are allocated from non-GC&#39;d memory, so any heap pointers
</span><span class="c1">// must be specially handled.
</span><span class="c1">//
</span><span class="c1">//go:notinheap
</span></code></pre></div><p><code>mcache</code>反映了对象的创建策略：小对象。</p>

		</div>
		<footer class="post__footer">
			
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5 0 11V3C0 1.5.8.8.8.8S1.5 0 3 0h8c1.5 0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/></svg>
	<ul class="tags__list">
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/golang/" rel="tag">golang</a>
		</li>
	</ul>
</div>
		</footer>
	</article>
</main>




			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2020 渐行渐远.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>