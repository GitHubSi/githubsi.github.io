<!DOCTYPE html>
<html>

<head>
    
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer">

<meta name="description" content="Hugo-Primer theme&#39;s example site">
<title>
    Gin使用 - 渐行渐远
</title>









<link rel="stylesheet" href="/css/main.min.670da4c21f08f6fb9346ba65b362026a143c88c6d6e4292b05476774b0516a42.css" integrity="sha256-Zw2kwh8I9vuTRrpls2ICahQ8iMbW5CkrBUdndLBRakI=" crossorigin="anonymous" media="screen">





<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic">

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Gin使用"/>
<meta name="twitter:description" content="Gin对net/http包做了封装，支持路由、中间件等特性，极大的方便对Http Server的开发。文章通过一个Test例子，来简要介绍。对"/>

<meta property="og:title" content="Gin使用" />
<meta property="og:description" content="Gin对net/http包做了封装，支持路由、中间件等特性，极大的方便对Http Server的开发。文章通过一个Test例子，来简要介绍。对" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://neojos.com/blog/2019/19-01-06-gin%E4%BD%BF%E7%94%A8/" />
<meta property="article:published_time" content="2019-01-05T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2019-01-05T00:00:00&#43;00:00"/>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-12345678-0', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

    

    
    
    
    <title>
        
        Gin使用
        
    </title>
</head>

<body>
    
    
    <header class="wrap flex-container">
        <h1>Gin使用</h1>
    </header>
    
    <main class="wrap">
        
        <article role="article" class="flex-container">

<p><a href="https://github.com/gin-gonic/gin"><code>Gin</code></a>对<code>net/http</code>包做了封装，支持路由、中间件等特性，极大的方便对<code>Http Server</code>的开发。文章通过一个<code>Test</code>例子，来简要介绍。对于特别基础的部分，请阅读参考文章。</p>

<h2 id="接口测试">接口测试</h2>

<p><code>Go</code>中<code>testing</code>包为程序自测提供了便利。可以查阅之前写的博客<a href="http://neojos.com/blog/2018/05-02-go-test%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/"><code>Go test基础用法</code></a>，对其内容，我还是挺满意的。</p>

<h3 id="使用-postman">使用<code>Postman</code></h3>

<p>对于接口测试，很多情况都在使用<code>Postman</code>这样的工具。首先在本地启动服务，然后在<code>Postman</code>中配置请求的地址和参数、执行请求、查看结果。</p>

<p>这种方式唯一让人不满意的地方在于：每次修改都需要重启服务。跟直接执行一次<code>Test</code>相比，明显多了一步。</p>

<h2 id="使用-test">使用<code>Test</code></h2>

<h4 id="测试基类">测试基类</h4>

<p>下面的代码作为接口测试的基类。</p>

<p><code>TestMain</code>中，我们为所有的测试用例指定通用的配置。之后在执行其他<code>Test</code>前，都会先执行<code>TestMain</code>中的代码。有效的避免了代码冗余。</p>

<p><code>getRouter</code>方法用于返回一个<code>gin</code>的实例。我们将服务的路由重新在<code>Test</code>中指定，并设置了中间件。</p>

<p><code>testHttpResponse</code>是我们请求处理的核心代码，发送请求，并保存响应到<code>w</code>中</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//common_test.go
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">TestMain</span><span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">M</span><span class="p">)</span> <span class="p">{</span>

	<span class="c1">//声明执行Test前的操作
</span><span class="c1"></span>	<span class="nx">gin</span><span class="p">.</span><span class="nf">SetMode</span><span class="p">(</span><span class="nx">gin</span><span class="p">.</span><span class="nx">TestMode</span><span class="p">)</span>
	<span class="nx">testutils</span><span class="p">.</span><span class="nf">NewTestApp</span><span class="p">(</span><span class="s">&#34;../conf.test.toml&#34;</span><span class="p">)</span>

	<span class="nx">flag</span><span class="p">.</span><span class="nf">Parse</span><span class="p">()</span>
	<span class="nx">os</span><span class="p">.</span><span class="nf">Exit</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nf">Run</span><span class="p">())</span>
<span class="p">}</span>

<span class="c1">//设置路由，获取框架Gin的实例
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">getRouter</span><span class="p">()</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Engine</span> <span class="p">{</span>
	<span class="nx">router</span> <span class="o">:=</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">Default</span><span class="p">()</span>

	<span class="c1">//配置路由，这是我项目中的自定义配置
</span><span class="c1"></span>	<span class="nx">router</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">middleware</span><span class="p">.</span><span class="nf">HeaderProcess</span><span class="p">())</span>
	<span class="nf">RouteAPI</span><span class="p">(</span><span class="nx">router</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">router</span>
<span class="p">}</span>

<span class="c1">//统一处理请求返回结果
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">testHttpResponse</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Engine</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">,</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">httptest</span><span class="p">.</span><span class="nx">ResponseRecorder</span><span class="p">)</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">w</span> <span class="o">:=</span> <span class="nx">httptest</span><span class="p">.</span><span class="nf">NewRecorder</span><span class="p">()</span>
	<span class="nx">r</span><span class="p">.</span><span class="nf">ServeHTTP</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">req</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">f</span><span class="p">(</span><span class="nx">w</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h4 id="测试用例">测试用例</h4>

<p>下面是具体的测试用例。我们构造了一个<code>Json</code>数据格式的<code>POST</code>请求，然后通过调用<code>testHttpResponse</code>方法来读取接口的响应数据。</p>

<p>关于<code>NewRequest</code>方法，它参数<code>body</code>传递一个<code>io.Reader</code>接口类型。从源代码可以看出，实现了该接口的分别是：<code>bytes.Buffer</code>   、<code>bytes.Reader</code>、<code>strings.Reader</code>。</p>

<pre><code>func TestWeChatRecharge(t *testing.T) {
	router := getRouter()

	//构造json的请求体
	params := map[string]interface{}{
		&quot;open_id&quot;:     &quot;olFg1s3gPcISnooRX9WSkX_E-cww&quot;,
		&quot;device_type&quot;: &quot;ANDROID&quot;,
	}
	jsonParams, _ := json.Marshal(params)
	readParams := bytes.NewReader(jsonParams)
	req, _ := http.NewRequest(&quot;POST&quot;, &quot;/pay/wx/recharge&quot;, readParams)
	req.Header.Set(&quot;Content-type&quot;, &quot;application/json&quot;)

	//发送请求
	testHttpResponse(t, router, req, func(w *httptest.ResponseRecorder) error {
		p, err := ioutil.ReadAll(w.Body)
		if err != nil {
			return err
		}

		t.Logf(&quot;%+v&quot;, string(p))
		return nil
	})
}
</code></pre>

<h4 id="小结">小结</h4>

<p>通过上述的步骤，我们实现了直接在<code>Test</code>中做接口测试。</p>

<h2 id="middleware"><code>Middleware</code></h2>

<p>声明一个<code>middleware</code>函数，返回类型为<code>type HandlerFunc func(*Context)</code>。</p>

<pre><code>func setUserStatus() gin.HandlerFunc {
	return func(c *gin.Context) {
		fmt.Println(&quot;set status&quot;)
	}
}
</code></pre>

<p>如果需要将函数应用于所有的请求，使用<code>Use</code>方法。比如统一的请求头转换、错误输出、日志打印等</p>

<pre><code>//Use adds middleware to the group
router.Use(setUserStatus())
</code></pre>

<p>下面是给具体的请求设置中间件。从这里可以看出，中间件处理函数和正常的业务处理函数类型是相同的。</p>

<pre><code>//Use a particular middleware
articleRoutes.GET(&quot;/create&quot;, setUserStatus(), showArticleCreationPage)
</code></pre>

<p>最后系统依次调用注册的<code>handler</code>完成请求处理：</p>

<pre><code>func (c *Context) Next() {
	c.index++
	for s := int8(len(c.handlers)); c.index &lt; s; c.index++ {
		c.handlers[c.index](c)
	}
}
</code></pre>

<hr />

<p>参考文章：</p>

<ol>
<li><a href="https://semaphoreci.com/community/tutorials/building-go-web-applications-and-microservices-using-gin"><code>Building Go Web Applications and Microservices Using Gin</code></a></li>
<li><a href="https://semaphoreci.com/community/tutorials/test-driven-development-of-go-web-applications-with-gin#"><code>Test-driven Development of Go Web Applications with Gin</code></a></li>
</ol>
</article>
        

        
        
        
    </main>
    
    <footer class="flex-container footer"></footer>
    
    
</body>

</html>