<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>think on 道法自然</title>
    <link>/tags/think/</link>
    <description>Recent content in think on 道法自然</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 24 Apr 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/think/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Kafka中消息分配策略</title>
      <link>/blog/2019/2019-04-24-kafka%E4%B8%AD%E6%B6%88%E6%81%AF%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</link>
      <pubDate>Wed, 24 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/2019/2019-04-24-kafka%E4%B8%AD%E6%B6%88%E6%81%AF%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</guid>
      <description>非淡泊无以明，非宁静无以致远
 Question 关于kafka中partation和consumer的是如何执行分配的。今早骑自行车的时候突然想起这个问题。它是怎么分配的，我记得我看到好几次相关的介绍文章，现在却想不起来？
sense 很多时候，我们在看完一篇技术文档时，感觉对其中的内容都了解了，其实不然。这也是所谓的被动输入和主动输出的区别所在。相比主动输出而言，被动输入缺少了深层思考的态度。得到一些老师的课里就谈到过主动输出的重要性。
很多概念都已经记不起来了，文章的内容可能也不够准确，但重在思考和想法的过程：
Thinking partaion是数据的存储单位，一个topic至少存在一个partation。consumer使用主动拉数据的方式来消费消息，这就是所有已知概念。那么partation和consumer是如何分配的呢？这里我们假设消息数据总量是一样的。
首先，应该存在一个类似LVS的负载均衡器，因为当consumer增加或者减少时，对应的分配策略也需要做相应的调整。在consumer注册成为消费者时，提交的信息中有consumer Group的概念，这非常好理解，即同一个组的consumer会独立处理一份数据。同时，因为有了Group，我们在管理的时候就会简单很多。当然，所有的讨论都是以一个Group为前提的。
1:1 从最简单的开始考虑，假设现在partation和consumer的数量比例是1:1，那就没有那么多事了，简单明了。
1:2 假设是1:2呢？问题来了，好比现在只有一个数据，但有AB两个线程都要读它，且A和B中有且只有一个能读到。这种情况在计算机中相当普遍，通用的处理方式就是加锁，以保证数据只被其中一个线程处理。但加锁就意味着性能开销，尤其是高并发的场景。
继续按照这个思路来考虑，两个consumer同时向一个partation发起请求，需要一个全局锁来控制每个消息只能返回给请求中的一个。相比较1:1的方式，这样的性能肯定是提高了不少。
2:1 假设是2:1呢？这个也很直观，两份数据，但只有一个消费者，那肯定都需要这一个消费者来处理了，就跟CPU任务调度还有些类似。
如果跟1:2的分配策略比较呢？这里通过将原来的一份数据平均分成两份，去掉了1:2中加锁的开销，但只有一个connsumer来消费数据。好比是单核CPU任意处理数据跟双核CPU加锁处理数据。
2:2 假设是2:2呢，我们可以平均分配partation和consumer，而且这样系统性能却得到最大提升，不仅去掉了锁的开销，还有两个线程来同时消费。
结论 通过上面的对比，我们可以清楚的发现，通过调整partation和consumer的数量就可以将系统性能达到最大，完全不需要引入锁机制。这样想的话，分配就很简单了。</description>
    </item>
    
    <item>
      <title>重试</title>
      <link>/blog/2018/07-24-%E9%87%8D%E8%AF%95/</link>
      <pubDate>Tue, 24 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/2018/07-24-%E9%87%8D%E8%AF%95/</guid>
      <description>为了克服网络问题，重试是我们常用的手段之一。但必须记住：重试的姿势非常重要。照应一句古话：“差若毫厘，谬以千里”。
正确的姿势是便是：
 如果请求没有成功，以指数型延迟重试
 指数退避  Exponential backoff is an algorithm that uses feedback to multiplicatively decrease the rate of some process, in order to gradually find an acceptable rate
 通俗的的讲，网络上的节点在发送数据冲突之后，不应立即尝试重发，而应该等待一段时间再发送，等待时间是指数增长，从而避免频繁的触发冲突。在计算机网络中，二进制指数退避算法常常作为避免网络堵塞的一部分，用于同一数据块的重发策略。
发生n次冲突之后，等待时间在0~2^n-1个间隙时间(slot time)之间随机选择。比如第一次冲突之后，每个发送方会等待0或者1个间隙；第二次冲突之后，或等待时间会在0到3个间隙任意选择，依次类推，随着冲突次数的增加，发送方等待的时间可能成倍增加。
冲突达到一定次数，指数运算会停止，表示等待时间不会无限制增加下去。比如设置上限n=10,则最长等待时间为1023个时间间隙。同样，发送不可能永远的尝试下去，所以流程一般会在16次重试之后终止。
具体的退避算法：
1. 确定基本退避时间：争用期 2. 确定等待时间上限(max)。假设重传次数超过10次之后,k就不再增大。计算公式：k表示计算冲突等待时间的指数， k=min（重传次数, max） 3. 当重传达到16次仍不成功，则数据需要丢弃，并向高层报告。  退避算法的应用场景：
1. 三方支付中交易结果的推送通知。 2. 轮询，不间断的固定时间间隔的请求接口。  重试的问题 以下面的代码说明一下：
retryTimes := 1 for err != nil &amp;amp;&amp;amp; retryTimes &amp;lt;= 3 { //请求失败后，重新尝试 body, err = curl.</description>
    </item>
    
    <item>
      <title>订单系统初识</title>
      <link>/blog/2018/06-08-%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F%E5%88%9D%E8%AF%86/</link>
      <pubDate>Fri, 08 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/2018/06-08-%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F%E5%88%9D%E8%AF%86/</guid>
      <description>计划将订单系统做一下梳理，包括之前写的IAP支付。其中一些细节，自己描述的也不是特别满意。后续慢慢的完善。
整个订单系统，概括的讲，其实就是创建订单、支付订单、交付权益这三个过程。但里面涉及的东西，可能必我们想象的要多很多。
订单号 在调用支付时，一般都会要求创建订单号。该订单号是标识本地交易的凭证，必须做到系统唯一。
创建订单号也有很多学问。最差也得做到：首先，不重复；其次，别人不能通过订单号，推测出任何有意义的信息；再次，订单号长度一定要做好控制。
订单再支付 描述一个场景：用户下单之后，并没有立即支付，而是过了一段时间，重新支付之前下的订单。这种情况，如果涉及到扣减库存，还会设置订单的过期时间。
重新支付的时候可能会有点问题：很多支付接口，不允许使用同一个订单号支付两次，即使上一次没有支付成功。换句话说，当你想重新支付时，系统需要生成一个新的订单号。
这样会导致：用户仅仅成功购买了一个商品，后台却生成了数笔订单。后期的统计变得麻烦了不少。
我们的做法便是：在确认支付时，生成两个订单，一个父订单，一个子订单。父订单用来标识用户的购买行为，子订单用户跟第三方支付。
订单统一管理 对于业务简单的部门来说，订单号自己创建，自己管理完全足够了。
但公司想汇总各个部门的订单数据时会变得异常麻烦。所以需要统一的订单创建平台。该平台负责订单的创建、以及后续订单的状态管理。
整个系统也开始变得复杂起来了。订单创建、订单状态更新都需要通知“订单系统”。数据也开始出现不一致。
交付 在用户下单、支付成功之后，将购买的商品或权益给到用户。
实物商品 将用户的购买行为添加到他的购买记录等，让快递员将商品送到用户手中等。
虚拟商品 用户在王者荣耀上买了一套皮肤，这就属于购买虚拟商品。最终腾讯只需要给用户的数据库写一条权益记录就好，不存在发货的过程。
签收 拆单 用户可能一次性购买多个商品，但系统只生成一个订单。对于实物商品，会涉及的拆单流程。比如用户买了肥皂和书，后台系统需要将肥皂交给卖家A来发货，将书交给卖家B来发。同样的商品，可能还会根据卖家和买家的距离来拆单。
签收 那么当更新订单签收状态时，就有疑问了。一个订单，它可能对应多个商品，那么只有商品全部被签收成功，才应该修改为已签收状态。但这种全部成功或者全部失败的状态，本身就很难保证。
所以签收应该针对具体商品。商城系统中，有两个常用的概念：SPU和SKU。那小米手机来举例，小米Note可以当作是一个SPU,而具体的红色-32G等能具体到一个实际的个体的就是SKU。
最终，签收状态应该是订单号+SKU_ID来决定的。
表结构设计 在用户下单、支付的过程中，跟订单内部商品的SKU关系不大，而且为了保证订单的幂等性,将订单设置为唯一索引是必须的。
在签收的过程中，无法做到针对订单来签收，而应该对订单下的SKU做签收。所以签收表应该独立出来。</description>
    </item>
    
    <item>
      <title>代码重构</title>
      <link>/blog/2018/05-12-%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84/</link>
      <pubDate>Sat, 12 May 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/2018/05-12-%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84/</guid>
      <description>重构自己的代码是一件幸福的事，重构别人的代码确是一件不幸的事。尤其是被重构代码的人还没有离职的时候&amp;hellip;
重构切记引入意外复杂度，同时要保证代码功能单一，没有冗余的、意义不明的代码存在。还要保证最简API原则。一个接口好坏，一定要明确区分：它不能再处理更多业务了，还是这些业务已经不能再被剥离了。
临时变量 这是重构的一个重要切入点。方法体内临时变量太多，尤其是一些词不表意的临时变量，理解维护是一件非常痛苦的事情。
是否可以将临时变量直接替换成方法调用，或者将临时变量规整到一个粒度更小的方法体中。
重复 代码重复，多处copy相同的代码，会让人迫不及待的想要重构。
项目中重复代码过多，会给维护、开发带来很大的不便。一个简单的逻辑修改，但却涉及修改好多处代码，还不能保证涉及的部分都修改了。这确实是一件头疼的事。
所以代码要做好封装：
 封装的粒度要把握好。一方面便于测试需要，另一方面通过组合，还能满足其他需求。 封装要考虑参数如何传递。包括是否应该包含成员变量，参数的个数多少合适。 封装的方法应该如何归类。怎样可以将方法归到最合适的类。  多态 当遇到很多的switch或者if-elseif的时候，可以考虑是否能用多态来替换。
比如下面的方法：
switch type { case movie.TV: case movie.Release }  需要特别提醒：movie包的常量作为判断条件，该方法就最好应该在movie包中。这样当需求变更时，便体现出最小修改原则。
我们提取一个movieType的抽象类，然后依次对每个类型实现相应的方法，通过声明类型为movieType的成员变量，实现不同类型的统一调用。
这里体现的是模块化的思想。将系统拆分成独立的模块，降低耦合度。这样做的好处：便于扩展。当新的类型添加时，对老的业务来说：零干扰。
但某些情况下，这样的拆分模式可能会有小缺陷。当类型是一个频繁被添加、修改的参数时，这样的模式就显得很冗余。这时可以使用属性拆分。将各个类型中的属性实现多态，也可以称做是一种策略转移。
使用类替换枚举类型 当一个类内含有多个常量枚举类型时，可以考虑将枚举类型的值封装成新的对象。这也是一个切入点。举个例子：
// original code const( Month int = iota Year int ) //modified code //将这些常量封装到另一个package中  访问成员变量 两个分歧：直接访问VS间接访问。两者均有好处，</description>
    </item>
    
  </channel>
</rss>