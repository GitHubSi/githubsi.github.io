<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>2018 on 付辉</title>
    <link>/tags/2018/</link>
    <description>Recent content in 2018 on 付辉</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 30 Mar 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/2018/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>版本管理工具</title>
      <link>/blog/2018/03-31-%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/</link>
      <pubDate>Fri, 30 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/2018/03-31-%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/</guid>
      <description> 反思之前的过程，一直没有试图跟上技术的发展。恍然觉得，其实技术比买股票更能让我找到快乐。新的技术越来越多，只能保持蜗牛锲而不舍的精神慢慢爬。
首先感谢这篇文章2018 年了，你还是只会 npm install 吗？，让我重新开始审视包管理工具。因为在PHP开发中有Composer，在Go的开发中有glide。但确实没有认真的去思考它们背后的那些为什么。
npm包管理 我其实一直不理解package.json和package-lock.json这两个文件的作用。直观上看，前者是我们项目所依赖的包，后者是各个包自身的明细依赖。但这样的设计却是经过版本迭代最终确定的形式。
当我们执行install或者update的时候，package-lock.json会根据nodemodules的更新进行相应更新。但有时候，我其实会手动的修改package.json文件，将别人下载好的依赖拷贝到我的目录下(不知道为啥下载不下来)。这个时候应该执行install还是update，我忘记啦，后面调查调查。
包的版本 版本号使用semver约束。其约定一个包的版本号必须包含3个数字，格式必须为 MAJOR.MINOR.PATCH, 意为 主版本号.小版本号.修订版本号。
还有就是主版本号相同的升级小版本必须提供向下兼容，但也仅仅是口头约束而已。提供了测试版本的网址：https://semver.npmjs.com/
 ^开头的版本：当前主版本下的大于等于小版本号的所有版本 ~开头的版本：当前主版本、小版本号下的的大于等于修正版本的版本 *或者x的版本：两者表示通配符 在常规仅包含数字的版本号之外：表示不稳定的发布版本  管理依赖 有时候，项目和项目之间存在引用关系。比如将项目中共有的类在common项目下维护，然后其他项目project-1和project-2分别引用项目common。当project项目变得越来越多时，每次新的项目都需要手动拷贝common代码。
可以将common做为一个包来管理。创建package.json文件，将common项目托管到git仓库。执行npm install git_url就可以将common作为依赖包进行安装了。
npm除了安装git仓库的代码，也可以安装本地的代码。
npm install file:local-package-path  版本管理 svn或者git只需要提交package.json, package-lock.json, 不要提交node_modules目录。
每次升级或降级版本，执行如下代码，相应的package.json，package-lock.json会自动更新：
npm install &amp;lt;package-name&amp;gt;@&amp;lt;version&amp;gt;  删除依赖包：
npm uninstall &amp;lt;package&amp;gt;  </description>
    </item>
    
  </channel>
</rss>