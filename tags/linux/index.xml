<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on 付辉</title>
    <link>/tags/linux/</link>
    <description>Recent content in Linux on 付辉</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 10 Jul 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Linux查看监听的端口进程</title>
      <link>/blog/2018/07-10-linux%E6%9F%A5%E7%9C%8B%E7%9B%91%E5%90%AC%E7%9A%84%E7%AB%AF%E5%8F%A3%E8%BF%9B%E7%A8%8B/</link>
      <pubDate>Tue, 10 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/2018/07-10-linux%E6%9F%A5%E7%9C%8B%E7%9B%91%E5%90%AC%E7%9A%84%E7%AB%AF%E5%8F%A3%E8%BF%9B%E7%A8%8B/</guid>
      <description>Netstat 是一款命令行工具，可用于列出系统上所有的网络套接字连接情况，包括 tcp, udp 以及 unix 套接字。另外它还能列出处于监听状态（即等待接入请求）的套接字。经常使用 netstat 用于查看网络连接信息和系统开启的端口号。
 还有一个完美替代它的命令ss，全称是socket statistics。ss的优点就在于“天下武功唯快不破”。
引言 已知服务监听的端口，想查找当前服务的PID。我们可以拆解成2个子问题： 1. 如何查看该端口是否在被服务监听 2. 如何查看该端口的PID
ps 用于查看服务器上的进程信息.最最常用的就是:
ps -ef  netstat 显示的状态列：Proto，Recv-Q，Send-Q，Local Address，Foreign Address，State。其中Recv-Q和Send-Q分别代表接收队列和发送队列。这些数字一般都是0，如果不是，则表示软件包正在队列中堆积。
Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 enlightened:domain *:* LISTEN  比较有用的选项是：
 -n：Show network addresses as numbers (normally netstat interprets addresses and attempts to display them symbolically). This option may be used with any of the display formats.</description>
    </item>
    
    <item>
      <title>shell操作文本实例</title>
      <link>/blog/2018/05-15-shell%E6%93%8D%E4%BD%9C%E6%96%87%E6%9C%AC%E5%AE%9E%E4%BE%8B/</link>
      <pubDate>Tue, 15 May 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/2018/05-15-shell%E6%93%8D%E4%BD%9C%E6%96%87%E6%9C%AC%E5%AE%9E%E4%BE%8B/</guid>
      <description>从掌握awk的基本指令，到在工作中熟练使用，中间还有一段路要走！通过总结一些工作中需要的案例，来加深理解。
打印符合条件的前一行记录 这个案例很抽象，可能非常难遇到，除非自己给自己挖坑。
业务代码中处理每条数据，都会顺序输出两条日志。第一条表示要处理的数据内容，第二条表示处理的结果。现在想滤出来所有处理成功的记录。比如日志文件如下：
uid=1 HAPPY uid=2 SAD uid=3 SAD  处理的AWK脚本如下：
#! /bin/bash # testPage表示日志文件 pieces=$(awk &#39;/HAPPY/{line=NR-1;print line}&#39; testPage | xargs) for piece in $pieces do echo $(awk NR==$piece testPage) done  脚本总结：
 首先通过正则表达式过滤，获取执行成功的数据行号。然后传递给xargs，转换为空格分隔的字符串。 遍历每个行号。值得注意，shell中对空格分隔的字符串可以直接使用for...in 通过awk条件判断，打印该行内容  求解两个文件的差集 使用comm实现 存在A和B两个系统，理论上A系统中的数据都应该存在于B系统中。但当核对数据时，发现两者数据不一致。如何有效的找出数据的差集。
具体到真实环境，通过MySQL，导出了满足条件的A、B系统数据的id，文件格式是csv。但当我执行如下列命令，获取仅仅在文件a中存在的记录时，发现数据完全不正确。
comm -2 -3 a.txt b.txt  调查发现，需要将两个文本先排好序，才能正常返回。
sort a.txt &amp;gt; a-sort.txt sort b.txt &amp;gt; b-sort.txt comm -2 -3 a-sort.txt b-sort.txt  使用uniq及sort实现 如下这种方式，仅仅可以找出不匹配的记录。无法区分数据是仅仅存在A系统，还是仅仅存在B系统。只能获取数据的交集和差集两部分。
原理很简单，将两个系统的文件合并到一个文件，然后排序。最终交集的数据，应该有2条记录。差集的记录，只有1条。
cat a.txt b.</description>
    </item>
    
  </channel>
</rss>