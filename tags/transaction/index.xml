<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>transaction on 渐行渐远</title>
    <link>/tags/transaction/</link>
    <description>Recent content in transaction on 渐行渐远</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 28 Feb 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/transaction/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>MySQL事务（2）</title>
      <link>/blog/2019/19-02-28-mysql%E4%BA%8B%E5%8A%A12/</link>
      <pubDate>Thu, 28 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/2019/19-02-28-mysql%E4%BA%8B%E5%8A%A12/</guid>
      <description>花繁柳密能拨开方见手段，风狂雨骤时可立定才是脚跟。
 引言 在MySQL处理事务的过程中，遇到如下报错：
Error 1205: Lock wait timeout exceeded; try restarting transaction  结合日志信息，很快的定位了问题代码并做了修复，但这个报错却一直存在。观念里，只要等待一段时间，这个错误就应该消失啊，是哪里出问题了？
问题 代码在执行Begin之后，处理到某个逻辑直接return处理，没有关闭事务导致的。因为SQL操作的记录一直占着锁得不到释放，所以后续对该行记录进行写操作时，就会报这个错误。示例代码如下：
func (notify *Sign) HandleSign(ctx *context.Context) error { // 事务操作，开启事务 if err := ses.Begin(); err != nil { return err } // 这里需要特别注意，正常情况必须加上 // defer ses.Close() // 更新Log表记录 _, err := ses.Where(&amp;quot;id = ?&amp;quot;, contractLog.Id).Cols(&amp;quot;status&amp;quot;).Update(contractLog) if err != nil { ses.Rollback() return err } //这个地方直接return导致的，这个事务没有关闭，导致上面的锁一直没有释放 return nil if err := ses.Commit(); err !</description>
    </item>
    
    <item>
      <title>数据一致性（一）</title>
      <link>/blog/2018/2018.10.20-%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%80/</link>
      <pubDate>Sat, 20 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/2018/2018.10.20-%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%80/</guid>
      <description>MySQL的事务是数据一致性的典范，事务内的执行要么都成功，要么都失败。但业务系统涉及系统间的相互调用，涉及的数据库也不尽相同，所以实现数据一致性还是有挑战的。
首先了解强一致性和弱一致性。在微服务中，系统间通过HTTP的方式相互调用，很难实现数据的强一致。我们这里主要说弱一致性，也就是数据最终一致性。
数据一致性还有个重要的前提：支持幂等。也就是说，只要请求参数不变，那么无论重复请求多少次，结果都一样。在对接第三方支付时，这个词出现的频率还是老高的。
基础理论 ACID  原子性Atomicity
 一致性Consistency
 隔离性Isolation
 持久性Durability
  如果涉及业务逻辑的数据被设计到同一个数据库中，借助事务的ACID可以很方便地解决。但现实情况是，要保证数据一致性的数据被分布在多个不同的数据库里。
CAP CAP理论说明任何分布式系统只可同时满足两点，无法三点都满足。
 一致性Consistency
 可用性Avaliability
  阮一峰老师的解释说：只要收到用户的请求，服务器就必须给出回应。
 分区容错Partition tolerance  BASE BASE模型实现的系统不保证强一致性，在处理请求的过程中，允许存在短暂的数据不一致。系统在处理流程的各个阶段，会更新记录的对应状态，后续通过状态来修复数据，最终达到数据一致。
 基本可用Basically Available 软状态Soft State 最终一致Eventually Consistency  购买业务 蜗牛要在一家电商网站买电子书，整个购买流程和涉及的系统虚构如下图。过程涉及检查它是否已经买过，然后是生成订单号、支付、交付（实际上订单系统不包含支付功能，这里简化处理）。


交付涉及三个系统，在任何一个系统内，数据库的事务都只能保证它服务内的数据一致。而且，如果在事务过程中引入了调用第三方的HTTP请求，数据库的事务执行结果甚至有可能会被污染。比如，HTTP请求超时返回失败，但实际上请求却执行成功的场景。
代码设计 参考之前写的 Saga Pattern模式，对任何一个外部服务的调用都引入两个行为：执行和补偿。补偿是对执行结果的修正。比如对于用户支付失败的场景，补偿行为可以是接口重试、可以是直接退款、还可以推送MQ异步修复等。
统一使用interface来定义一套规范。每一种支付方式以及购买产品所调用的外部服务可能不尽相同，用interface来达到统一调用的目的。补偿的行为都基于执行动作返回的错误，所以我们需要实现自己的错误码。
type DeliverPattern interface { //是否需要执行交付流程 Check(ctx *context.Context) (bool, error) //支付及支付补偿 DoPay(ctx *context.Context) error PayCompensate(ctx *context.Context, doErr error) error //交付及对应的补偿 DoDeliver(ctx *context.</description>
    </item>
    
    <item>
      <title>Saga Pattern</title>
      <link>/blog/2018/04-24-saga-pattern/</link>
      <pubDate>Tue, 24 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/2018/04-24-saga-pattern/</guid>
      <description>在微服务中，用的比较多的分布式事务模式：SAGA。下面是lysu/go-saga库中的描述：
 Saga is a long-lived transaction came up with many small sub-transaction.ExecutionCoordinator(SEC) is coordinator for sub-transactions execute and saga-log written.Sub-transaction is normal business operation, it contain a Action and action&amp;rsquo;s Compensate. Saga-Log is used to record saga process, and SEC will use it to decide next step and how to recovery from error.Log presents Saga Log. Saga Log used to log execute status for saga, and SEC use it to compensate and retry.</description>
    </item>
    
  </channel>
</rss>